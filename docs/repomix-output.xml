This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
001/
  plan.md
  spec.md
002/
  plan.md
  spec.md
003/
  plan.md
  spec.md
database.md
naver_map_SDK.md
prd.md
requirements.md
state-management.md
userflow.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="001/plan.md">
# UC-001: 장소 검색 및 정보 확인 - 구현 계획

## 1. Feature Overview

### 1.1 목표
네이버 지도 SDK와 검색 API를 활용하여 사용자가 음식점을 검색하고, 지도에서 마커로 확인하며, 상세 정보와 리뷰를 조회할 수 있는 기능을 구현합니다.

### 1.2 주요 기능
- 네이버 장소 검색 API를 통한 음식점 검색
- 검색 결과 리스트 표시 및 지도 마커 연동
- 장소 세부 정보 모달 (업체 정보, 평균 별점, 리뷰 목록)
- 리뷰가 있는 장소의 커스텀 마커 표시
- 모달 네비게이션 (검색 결과 ↔ 장소 상세 ↔ 메인 지도)

### 1.3 기술 스택
- **프론트엔드**: Next.js 14 App Router, React 18, TypeScript
- **상태 관리**: Zustand (모달/UI), React Query (서버 데이터), react-hook-form (검색 폼)
- **백엔드**: Hono (API Router), Supabase (Database)
- **외부 API**: 네이버 지도 SDK, 네이버 검색 API
- **스키마 검증**: Zod
- **UI 컴포넌트**: shadcn-ui, Tailwind CSS

---

## 2. Technical Architecture

### 2.1 시스템 아키텍처

```mermaid
graph TB
    subgraph Client["클라이언트 레이어"]
        UI[UI Components]
        Zustand[Zustand Store<br/>모달/지도 상태]
        ReactQuery[React Query<br/>서버 데이터 캐싱]
        RHF[react-hook-form<br/>검색 폼]
    end

    subgraph External["외부 API"]
        NaverSDK[네이버 지도 SDK]
        NaverSearch[네이버 검색 API]
    end

    subgraph Backend["백엔드 레이어"]
        Hono[Hono API Routes]
        Service[Service Layer]
        Supabase[(Supabase DB)]
    end

    UI --> Zustand
    UI --> ReactQuery
    UI --> RHF
    UI --> NaverSDK
    ReactQuery --> Hono
    Hono --> Service
    Hono --> NaverSearch
    Service --> Supabase
```

### 2.2 상태 관리 계층

```
┌─────────────────────────────────────────────────┐
│         Zustand (Global UI State)               │
│  - modalState: 'closed' | 'search-results' |    │
│                'place-detail'                    │
│  - modalHistory: ModalHistoryItem[]             │
│  - highlightedMarkerId: string | null           │
│  - mapCenter: { lat, lng }                      │
└─────────────────────────────────────────────────┘
                      ↓
┌─────────────────────────────────────────────────┐
│       React Query (Server State)                │
│  - places/with-reviews (지도 마커용)             │
│  - places/search?query={keyword}                │
│  - places/:naverPlaceId                         │
│  - places/:placeId/reviews                      │
└─────────────────────────────────────────────────┘
                      ↓
┌─────────────────────────────────────────────────┐
│       react-hook-form (Form State)              │
│  - searchQuery: string                          │
└─────────────────────────────────────────────────┘
```

### 2.3 컴포넌트 구조

```
src/app/page.tsx (메인 페이지)
  ├── SearchBar (검색 폼)
  ├── NaverMap (지도 컴포넌트)
  │   └── PlaceMarker[] (마커 컴포넌트)
  ├── SearchResultsModal (검색 결과 모달)
  │   └── SearchResultItem[] (검색 결과 항목)
  └── PlaceDetailModal (장소 상세 모달)
      ├── PlaceInfo (장소 정보)
      ├── ReviewStats (평균 별점, 리뷰 개수)
      └── ReviewList (리뷰 목록)
          └── ReviewItem[] (리뷰 항목)
```

---

## 3. Implementation Plan

### 3.1 개요: 모듈 및 작업 위치

| 모듈 | 경로 | 설명 |
|------|------|------|
| **백엔드 API** | `src/features/places/backend/` | 장소 검색, 조회 API |
| **백엔드 API** | `src/features/reviews/backend/` | 리뷰 조회 API |
| **Zustand Store** | `src/stores/useAppStore.ts` | 모달 및 지도 상태 관리 |
| **React Query Hooks** | `src/features/places/hooks/` | 장소 검색, 조회 훅 |
| **React Query Hooks** | `src/features/reviews/hooks/` | 리뷰 조회 훅 |
| **UI Components** | `src/features/places/components/` | 지도, 검색, 모달 컴포넌트 |
| **네이버 SDK 설정** | `src/app/layout.tsx` | 네이버 지도 SDK 스크립트 로드 |
| **메인 페이지** | `src/app/page.tsx` | 지도 및 모달 통합 페이지 |
| **Database Migration** | `supabase/migrations/0002_create_places_and_reviews.sql` | places, reviews 테이블 생성 |

### 3.2 Diagram: 모듈 간 관계

```mermaid
graph LR
    subgraph Frontend
        Page[page.tsx]
        SearchBar[SearchBar]
        NaverMap[NaverMap]
        SearchModal[SearchResultsModal]
        DetailModal[PlaceDetailModal]
        AppStore[useAppStore]
    end

    subgraph Hooks
        usePlaces[usePlacesWithReviews]
        useSearch[useSearchPlaces]
        usePlace[usePlaceByNaverId]
        useReviews[useReviews]
    end

    subgraph Backend
        PlacesRoute[places/backend/route.ts]
        PlacesService[places/backend/service.ts]
        ReviewsRoute[reviews/backend/route.ts]
        ReviewsService[reviews/backend/service.ts]
    end

    subgraph External
        NaverSDK[네이버 지도 SDK]
        NaverAPI[네이버 검색 API]
    end

    subgraph Database
        PlacesTable[(places)]
        ReviewsTable[(reviews)]
    end

    Page --> SearchBar
    Page --> NaverMap
    Page --> SearchModal
    Page --> DetailModal
    Page --> AppStore

    SearchBar --> useSearch
    NaverMap --> usePlaces
    SearchModal --> AppStore
    DetailModal --> usePlace
    DetailModal --> useReviews

    usePlaces --> PlacesRoute
    useSearch --> PlacesRoute
    usePlace --> PlacesRoute
    useReviews --> ReviewsRoute

    PlacesRoute --> PlacesService
    PlacesRoute --> NaverAPI
    ReviewsRoute --> ReviewsService

    PlacesService --> PlacesTable
    ReviewsService --> ReviewsTable
    ReviewsTable -.FK.-> PlacesTable

    NaverMap --> NaverSDK
```

---

## 4. API Specifications

### 4.1 Backend API Endpoints

#### 1) GET /api/places/search

**목적**: 네이버 장소 검색 API를 프록시하여 검색 결과 반환

**요청**
```typescript
GET /api/places/search?query=강남+맛집&display=5
```

**요청 스키마** (`src/features/places/backend/schema.ts`)
```typescript
export const SearchPlacesQuerySchema = z.object({
  query: z.string().min(1, '검색어를 입력해주세요'),
  display: z.coerce.number().int().min(1).max(5).default(5),
});

export type SearchPlacesQuery = z.infer<typeof SearchPlacesQuerySchema>;
```

**응답 스키마**
```typescript
export const NaverPlaceSchema = z.object({
  id: z.string(), // 네이버 place_id
  name: z.string(),
  address: z.string(),
  roadAddress: z.string().optional(),
  phone: z.string().optional(),
  latitude: z.number(),
  longitude: z.number(),
  category: z.string().optional(),
});

export const SearchPlacesResponseSchema = z.object({
  places: z.array(NaverPlaceSchema),
  total: z.number(),
});

export type NaverPlace = z.infer<typeof NaverPlaceSchema>;
export type SearchPlacesResponse = z.infer<typeof SearchPlacesResponseSchema>;
```

**응답 예시**
```json
{
  "ok": true,
  "data": {
    "places": [
      {
        "id": "naver_12345678",
        "name": "강남 맛집",
        "address": "서울시 강남구 역삼동",
        "roadAddress": "서울시 강남구 테헤란로 123",
        "phone": "02-1234-5678",
        "latitude": 37.498095,
        "longitude": 127.027610,
        "category": "음식점>한식"
      }
    ],
    "total": 1
  }
}
```

#### 2) GET /api/places/:naver_place_id

**목적**: 네이버 장소 ID로 places 테이블 조회 또는 생성

**요청**
```typescript
GET /api/places/naver_12345678
```

**요청 스키마**
```typescript
export const PlaceParamsSchema = z.object({
  naver_place_id: z.string().min(1),
});

export type PlaceParams = z.infer<typeof PlaceParamsSchema>;
```

**응답 스키마**
```typescript
export const PlaceResponseSchema = z.object({
  id: z.string().uuid(),
  naver_place_id: z.string(),
  name: z.string(),
  address: z.string(),
  phone: z.string().nullable(),
  latitude: z.number(),
  longitude: z.number(),
  created_at: z.string(),
  updated_at: z.string(),
});

export type PlaceResponse = z.infer<typeof PlaceResponseSchema>;
```

**처리 로직**:
1. places 테이블에서 naver_place_id로 조회
2. 존재하면 해당 데이터 반환
3. 없으면 네이버 검색 API로 장소 정보 조회 후 places 테이블에 INSERT 후 반환

#### 3) GET /api/places/with-reviews

**목적**: 리뷰가 존재하는 모든 장소 조회 (지도 마커 표시용)

**요청**
```typescript
GET /api/places/with-reviews
```

**응답 스키마**
```typescript
export const PlacesWithReviewsResponseSchema = z.array(
  z.object({
    id: z.string().uuid(),
    naver_place_id: z.string(),
    name: z.string(),
    latitude: z.number(),
    longitude: z.number(),
  })
);

export type PlacesWithReviewsResponse = z.infer<typeof PlacesWithReviewsResponseSchema>;
```

**SQL**
```sql
SELECT DISTINCT p.id, p.naver_place_id, p.name, p.latitude, p.longitude
FROM places p
INNER JOIN reviews r ON p.id = r.place_id;
```

#### 4) GET /api/places/:place_id/reviews

**목적**: 특정 장소의 리뷰 목록 및 통계 조회

**요청**
```typescript
GET /api/places/uuid-1234/reviews
```

**요청 스키마**
```typescript
export const ReviewsParamsSchema = z.object({
  place_id: z.string().uuid(),
});

export type ReviewsParams = z.infer<typeof ReviewsParamsSchema>;
```

**응답 스키마** (`src/features/reviews/backend/schema.ts`)
```typescript
export const ReviewSchema = z.object({
  id: z.string().uuid(),
  place_id: z.string().uuid(),
  author_name: z.string(),
  rating: z.number().int().min(1).max(5),
  content: z.string(),
  created_at: z.string(),
});

export const ReviewStatsSchema = z.object({
  avg_rating: z.number().min(0).max(5),
  review_count: z.number().int().min(0),
});

export const ReviewsResponseSchema = z.object({
  place_id: z.string().uuid(),
  reviews: z.array(ReviewSchema),
  stats: ReviewStatsSchema,
});

export type Review = z.infer<typeof ReviewSchema>;
export type ReviewStats = z.infer<typeof ReviewStatsSchema>;
export type ReviewsResponse = z.infer<typeof ReviewsResponseSchema>;
```

**SQL**
```sql
-- 리뷰 목록 조회
SELECT id, place_id, author_name, rating, content, created_at
FROM reviews
WHERE place_id = $1
ORDER BY created_at DESC;

-- 평균 별점 및 개수
SELECT
  COALESCE(AVG(rating), 0) as avg_rating,
  COUNT(*) as review_count
FROM reviews
WHERE place_id = $1;
```

---

## 5. State Management Details

### 5.1 Zustand Store (`src/stores/useAppStore.ts`)

```typescript
import { create } from 'zustand';

type ModalState = 'closed' | 'search-results' | 'place-detail';

interface ModalHistoryItem {
  type: Exclude<ModalState, 'closed'>;
  data?: {
    placeId?: string;
    naverPlaceId?: string;
    searchQuery?: string;
  };
}

interface AppState {
  // Modal 관리
  modalState: ModalState;
  modalHistory: ModalHistoryItem[];
  openModal: (type: Exclude<ModalState, 'closed'>, data?: ModalHistoryItem['data']) => void;
  closeModal: () => void;
  goBackModal: () => void;

  // Map 관리
  highlightedMarkerId: string | null;
  mapCenter: { lat: number; lng: number };
  setHighlightedMarker: (id: string | null) => void;
  setMapCenter: (lat: number, lng: number) => void;
}

export const useAppStore = create<AppState>((set, get) => ({
  // 초기 상태
  modalState: 'closed',
  modalHistory: [],
  highlightedMarkerId: null,
  mapCenter: { lat: 37.498095, lng: 127.027610 }, // 강남역

  // Modal Actions
  openModal: (type, data) =>
    set((state) => ({
      modalState: type,
      modalHistory: [...state.modalHistory, { type, data }],
    })),

  closeModal: () =>
    set({
      modalState: 'closed',
      modalHistory: [],
      highlightedMarkerId: null,
    }),

  goBackModal: () =>
    set((state) => {
      const newHistory = [...state.modalHistory];
      newHistory.pop();
      const prevModal = newHistory[newHistory.length - 1];

      return {
        modalState: prevModal?.type || 'closed',
        modalHistory: newHistory,
      };
    }),

  // Map Actions
  setHighlightedMarker: (id) => set({ highlightedMarkerId: id }),
  setMapCenter: (lat, lng) => set({ mapCenter: { lat, lng } }),
}));
```

### 5.2 React Query Hooks

#### `src/features/places/hooks/usePlaces.ts`

```typescript
import { useQuery } from '@tanstack/react-query';
import { apiClient } from '@/lib/remote/api-client';
import type { PlacesWithReviewsResponse, PlaceResponse, SearchPlacesResponse } from '../lib/dto';

// 리뷰가 있는 장소 목록 조회 (지도 마커용)
export const usePlacesWithReviews = () => {
  return useQuery({
    queryKey: ['places', 'with-reviews'],
    queryFn: async () => {
      const response = await apiClient.get<{ ok: boolean; data: PlacesWithReviewsResponse }>(
        '/api/places/with-reviews'
      );
      return response.data.data;
    },
    staleTime: 5 * 60 * 1000, // 5분
  });
};

// 네이버 장소 검색
export const useSearchPlaces = (query: string, enabled: boolean = true) => {
  return useQuery({
    queryKey: ['places', 'search', query],
    queryFn: async () => {
      const response = await apiClient.get<{ ok: boolean; data: SearchPlacesResponse }>(
        '/api/places/search',
        { params: { query, display: 5 } }
      );
      return response.data.data;
    },
    enabled: !!query && enabled,
    staleTime: 1 * 60 * 1000, // 1분
  });
};

// 네이버 장소 ID로 조회 또는 생성
export const usePlaceByNaverId = (naverPlaceId: string | null) => {
  return useQuery({
    queryKey: ['places', 'naver', naverPlaceId],
    queryFn: async () => {
      const response = await apiClient.get<{ ok: boolean; data: PlaceResponse }>(
        `/api/places/${naverPlaceId}`
      );
      return response.data.data;
    },
    enabled: !!naverPlaceId,
    staleTime: 10 * 60 * 1000, // 10분
  });
};
```

#### `src/features/reviews/hooks/useReviews.ts`

```typescript
import { useQuery } from '@tanstack/react-query';
import { apiClient } from '@/lib/remote/api-client';
import type { ReviewsResponse } from '../lib/dto';

export const useReviews = (placeId: string | null) => {
  return useQuery({
    queryKey: ['reviews', placeId],
    queryFn: async () => {
      const response = await apiClient.get<{ ok: boolean; data: ReviewsResponse }>(
        `/api/places/${placeId}/reviews`
      );
      return response.data.data;
    },
    enabled: !!placeId,
    staleTime: 30 * 1000, // 30초
  });
};
```

### 5.3 react-hook-form 검색 폼

```typescript
// src/features/places/components/SearchBar.tsx
'use client';

import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';
import { useAppStore } from '@/stores/useAppStore';

const searchFormSchema = z.object({
  query: z.string().min(1, '검색어를 입력해주세요'),
});

type SearchFormData = z.infer<typeof searchFormSchema>;

export const SearchBar = () => {
  const openModal = useAppStore((state) => state.openModal);

  const form = useForm<SearchFormData>({
    resolver: zodResolver(searchFormSchema),
    defaultValues: { query: '' },
  });

  const onSubmit = (data: SearchFormData) => {
    openModal('search-results', { searchQuery: data.query });
  };

  return (
    <form onSubmit={form.handleSubmit(onSubmit)}>
      {/* 검색 입력 필드 */}
    </form>
  );
};
```

---

## 6. Component Hierarchy

### 6.1 페이지 구조

```typescript
// src/app/page.tsx
'use client';

import { SearchBar } from '@/features/places/components/SearchBar';
import { NaverMap } from '@/features/places/components/NaverMap';
import { SearchResultsModal } from '@/features/places/components/SearchResultsModal';
import { PlaceDetailModal } from '@/features/places/components/PlaceDetailModal';

export default function HomePage() {
  return (
    <div className="h-screen flex flex-col">
      <SearchBar />
      <NaverMap />
      <SearchResultsModal />
      <PlaceDetailModal />
    </div>
  );
}
```

### 6.2 컴포넌트 목록

| 컴포넌트 | 경로 | 책임 |
|----------|------|------|
| `SearchBar` | `src/features/places/components/SearchBar.tsx` | 검색 폼, 검색 실행 |
| `NaverMap` | `src/features/places/components/NaverMap.tsx` | 네이버 지도 SDK 래핑, 마커 표시 |
| `PlaceMarker` | `src/features/places/components/PlaceMarker.tsx` | 개별 마커 컴포넌트 |
| `SearchResultsModal` | `src/features/places/components/SearchResultsModal.tsx` | 검색 결과 모달 |
| `SearchResultItem` | `src/features/places/components/SearchResultItem.tsx` | 검색 결과 개별 항목 |
| `PlaceDetailModal` | `src/features/places/components/PlaceDetailModal.tsx` | 장소 상세 모달 |
| `PlaceInfo` | `src/features/places/components/PlaceInfo.tsx` | 장소 정보 표시 |
| `ReviewStats` | `src/features/reviews/components/ReviewStats.tsx` | 평균 별점, 리뷰 개수 |
| `ReviewList` | `src/features/reviews/components/ReviewList.tsx` | 리뷰 목록 |
| `ReviewItem` | `src/features/reviews/components/ReviewItem.tsx` | 리뷰 개별 항목 |

### 6.3 데이터 흐름

```mermaid
sequenceDiagram
    participant User
    participant SearchBar
    participant Zustand
    participant ReactQuery
    participant API
    participant Map
    participant Modal

    User->>SearchBar: 검색어 입력 후 제출
    SearchBar->>Zustand: openModal('search-results')
    SearchBar->>ReactQuery: useSearchPlaces(query)
    ReactQuery->>API: GET /api/places/search
    API-->>ReactQuery: 검색 결과
    ReactQuery-->>Modal: 데이터 전달
    Zustand-->>Modal: 모달 상태 업데이트
    Modal-->>User: 검색 결과 모달 표시

    User->>Modal: 검색 결과 항목 선택
    Modal->>Zustand: setHighlightedMarker(id)
    Zustand-->>Map: 마커 강조 표시

    User->>Modal: "장소 세부 정보" 클릭
    Modal->>Zustand: openModal('place-detail', { naverPlaceId })
    Modal->>ReactQuery: usePlaceByNaverId(naverPlaceId)
    ReactQuery->>API: GET /api/places/:naver_place_id
    API-->>ReactQuery: 장소 정보
    Modal->>ReactQuery: useReviews(placeId)
    ReactQuery->>API: GET /api/places/:place_id/reviews
    API-->>ReactQuery: 리뷰 데이터
    ReactQuery-->>Modal: 데이터 전달
    Modal-->>User: 장소 상세 모달 표시

    User->>Modal: 모달 닫기
    Modal->>Zustand: goBackModal()
    Zustand-->>Modal: 직전 모달 상태로 복귀
```

---

## 7. Error Handling

### 7.1 Backend Error Codes

#### `src/features/places/backend/error.ts`

```typescript
export const placeErrorCodes = {
  searchError: 'PLACE_SEARCH_ERROR',
  naverApiError: 'NAVER_API_ERROR',
  fetchError: 'PLACE_FETCH_ERROR',
  notFound: 'PLACE_NOT_FOUND',
  validationError: 'PLACE_VALIDATION_ERROR',
  createError: 'PLACE_CREATE_ERROR',
} as const;

export type PlaceServiceError = keyof typeof placeErrorCodes;
```

#### `src/features/reviews/backend/error.ts`

```typescript
export const reviewErrorCodes = {
  fetchError: 'REVIEW_FETCH_ERROR',
  validationError: 'REVIEW_VALIDATION_ERROR',
} as const;

export type ReviewServiceError = keyof typeof reviewErrorCodes;
```

### 7.2 에러 처리 전략

| 에러 케이스 | HTTP 상태 | 에러 코드 | 처리 방법 |
|------------|----------|----------|----------|
| 검색 결과 없음 | 200 | - | `places: [], total: 0` 반환 |
| 네이버 API 호출 실패 | 500 | `NAVER_API_ERROR` | 에러 메시지 표시 |
| 장소 조회 실패 | 404 | `PLACE_NOT_FOUND` | "존재하지 않는 장소입니다" 표시 |
| 리뷰 없음 | 200 | - | `reviews: [], stats: { avg_rating: 0, review_count: 0 }` |
| 데이터베이스 오류 | 500 | `FETCH_ERROR` | "정보를 불러오는 중 오류가 발생했습니다" |
| 검증 오류 | 400 | `VALIDATION_ERROR` | 상세 검증 오류 메시지 표시 |

### 7.3 프론트엔드 에러 처리

```typescript
// src/features/places/components/SearchResultsModal.tsx
'use client';

import { useAppStore } from '@/stores/useAppStore';
import { useSearchPlaces } from '../hooks/usePlaces';

export const SearchResultsModal = () => {
  const modalState = useAppStore((state) => state.modalState);
  const modalHistory = useAppStore((state) => state.modalHistory);

  const currentModal = modalHistory[modalHistory.length - 1];
  const searchQuery = currentModal?.data?.searchQuery || '';

  const { data, isLoading, isError, error } = useSearchPlaces(
    searchQuery,
    modalState === 'search-results'
  );

  if (isError) {
    return (
      <div>
        <p>검색에 실패했습니다.</p>
        <p>{error instanceof Error ? error.message : '다시 시도해주세요'}</p>
      </div>
    );
  }

  if (data?.places.length === 0) {
    return <div>검색 결과가 없습니다</div>;
  }

  // 정상 렌더링
};
```

---

## 8. Testing Strategy

### 8.1 Unit Tests

#### Backend Service Tests

**`src/features/places/backend/__tests__/service.test.ts`**

```typescript
import { describe, it, expect, vi } from 'vitest';
import { getPlaceByNaverId, searchPlaces } from '../service';

describe('places/service', () => {
  describe('searchPlaces', () => {
    it('네이버 API 호출 성공 시 변환된 데이터를 반환한다', async () => {
      // Given: Mock fetch
      global.fetch = vi.fn().mockResolvedValue({
        ok: true,
        json: async () => ({
          items: [
            {
              title: '<b>강남</b> 맛집',
              address: '서울시 강남구',
              mapx: '1270276100',
              mapy: '374980950',
            },
          ],
          total: 1,
        }),
      });

      // When
      const result = await searchPlaces('강남 맛집', 5);

      // Then
      expect(result.ok).toBe(true);
      if (result.ok) {
        expect(result.data.places).toHaveLength(1);
        expect(result.data.places[0].name).toBe('강남 맛집');
        expect(result.data.places[0].latitude).toBeCloseTo(37.498095, 5);
      }
    });

    it('네이버 API 호출 실패 시 에러를 반환한다', async () => {
      // Given
      global.fetch = vi.fn().mockResolvedValue({
        ok: false,
        status: 500,
      });

      // When
      const result = await searchPlaces('강남 맛집', 5);

      // Then
      expect(result.ok).toBe(false);
      if (!result.ok) {
        expect(result.error.code).toBe('NAVER_API_ERROR');
      }
    });
  });

  describe('getPlaceByNaverId', () => {
    it('places 테이블에 데이터가 있으면 반환한다', async () => {
      // Given: Mock Supabase client
      const mockSupabase = {
        from: vi.fn().mockReturnValue({
          select: vi.fn().mockReturnValue({
            eq: vi.fn().mockReturnValue({
              maybeSingle: vi.fn().mockResolvedValue({
                data: {
                  id: 'uuid-1',
                  naver_place_id: 'naver_123',
                  name: '강남 맛집',
                  address: '서울시 강남구',
                  phone: '02-1234-5678',
                  latitude: 37.498095,
                  longitude: 127.027610,
                  created_at: '2025-10-22T00:00:00Z',
                  updated_at: '2025-10-22T00:00:00Z',
                },
                error: null,
              }),
            }),
          }),
        }),
      };

      // When
      const result = await getPlaceByNaverId(mockSupabase as any, 'naver_123');

      // Then
      expect(result.ok).toBe(true);
      if (result.ok) {
        expect(result.data.name).toBe('강남 맛집');
      }
    });
  });
});
```

#### React Query Hook Tests

**`src/features/places/hooks/__tests__/usePlaces.test.ts`**

```typescript
import { renderHook, waitFor } from '@testing-library/react';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { usePlacesWithReviews } from '../usePlaces';

const createWrapper = () => {
  const queryClient = new QueryClient({
    defaultOptions: { queries: { retry: false } },
  });

  return ({ children }: { children: React.ReactNode }) => (
    <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
  );
};

describe('usePlacesWithReviews', () => {
  it('리뷰가 있는 장소 목록을 성공적으로 조회한다', async () => {
    // When
    const { result } = renderHook(() => usePlacesWithReviews(), {
      wrapper: createWrapper(),
    });

    // Then
    await waitFor(() => expect(result.current.isSuccess).toBe(true));
    expect(result.current.data).toBeDefined();
  });
});
```

### 8.2 Integration Tests

#### API Route Tests

**`src/features/places/backend/__tests__/route.test.ts`**

```typescript
import { describe, it, expect } from 'vitest';
import { createHonoApp } from '@/backend/hono/app';

describe('GET /api/places/search', () => {
  it('검색어가 있으면 200과 검색 결과를 반환한다', async () => {
    // Given
    const app = createHonoApp();

    // When
    const res = await app.request('/api/places/search?query=강남+맛집');

    // Then
    expect(res.status).toBe(200);
    const json = await res.json();
    expect(json.ok).toBe(true);
    expect(json.data).toHaveProperty('places');
    expect(json.data).toHaveProperty('total');
  });

  it('검색어가 없으면 400을 반환한다', async () => {
    // Given
    const app = createHonoApp();

    // When
    const res = await app.request('/api/places/search');

    // Then
    expect(res.status).toBe(400);
    const json = await res.json();
    expect(json.ok).toBe(false);
    expect(json.error.code).toBe('INVALID_SEARCH_PARAMS');
  });
});
```

### 8.3 E2E Tests (선택적)

#### Playwright 시나리오

```typescript
// e2e/search-and-view-place.spec.ts
import { test, expect } from '@playwright/test';

test('장소 검색 및 정보 확인', async ({ page }) => {
  // Given: 메인 페이지 접속
  await page.goto('/');

  // When: 검색어 입력 후 검색
  await page.fill('input[name="query"]', '강남 맛집');
  await page.click('button[type="submit"]');

  // Then: 검색 결과 모달 표시
  await expect(page.locator('[data-testid="search-results-modal"]')).toBeVisible();

  // When: 첫 번째 검색 결과 선택
  await page.click('[data-testid="search-result-item"]:first-child');

  // Then: 마커 강조 표시 확인 (시각적 테스트는 스냅샷 활용)

  // When: "장소 세부 정보" 버튼 클릭
  await page.click('[data-testid="view-place-detail-button"]');

  // Then: 장소 상세 모달 표시
  await expect(page.locator('[data-testid="place-detail-modal"]')).toBeVisible();
  await expect(page.locator('[data-testid="place-name"]')).toContainText('맛집');
  await expect(page.locator('[data-testid="review-stats"]')).toBeVisible();
});
```

---

## 9. Implementation Checklist

### 9.1 Prerequisites

- [ ] shadcn-ui 컴포넌트 설치
  ```bash
  npx shadcn@latest add dialog
  npx shadcn@latest add input
  npx shadcn@latest add button
  npx shadcn@latest add card
  npx shadcn@latest add scroll-area
  ```

- [ ] 네이버 지도 TypeScript 타입 설치
  ```bash
  npm install --save-dev @types/navermaps
  ```

- [ ] 환경 변수 설정 (`.env.local`)
  ```env
  NEXT_PUBLIC_NAVER_CLIENT_ID=your_client_id
  NAVER_CLIENT_SECRET=your_client_secret
  ```

### 9.2 Backend Implementation

- [ ] **Database Migration** (`supabase/migrations/0002_create_places_and_reviews.sql`)
  - places 테이블 생성
  - reviews 테이블 생성
  - 인덱스 생성 (`naver_place_id`, `place_id`, `created_at`)
  - updated_at 자동 업데이트 트리거

- [ ] **Places Backend**
  - [ ] `src/features/places/backend/schema.ts`: Zod 스키마 정의
  - [ ] `src/features/places/backend/error.ts`: 에러 코드 정의
  - [ ] `src/features/places/backend/service.ts`: 비즈니스 로직
    - `searchPlaces(query, display)`: 네이버 검색 API 호출
    - `getPlaceByNaverId(supabase, naverPlaceId)`: 조회 또는 생성
    - `getPlacesWithReviews(supabase)`: 리뷰 있는 장소 조회
  - [ ] `src/features/places/backend/route.ts`: Hono 라우터 등록
    - `GET /api/places/search`
    - `GET /api/places/:naver_place_id`
    - `GET /api/places/with-reviews`
  - [ ] `src/features/places/lib/dto.ts`: 스키마 재노출

- [ ] **Reviews Backend**
  - [ ] `src/features/reviews/backend/schema.ts`: Zod 스키마 정의
  - [ ] `src/features/reviews/backend/error.ts`: 에러 코드 정의
  - [ ] `src/features/reviews/backend/service.ts`: 비즈니스 로직
    - `getReviewsByPlaceId(supabase, placeId)`: 리뷰 목록 조회
    - `getReviewStats(supabase, placeId)`: 평균 별점/개수 계산
  - [ ] `src/features/reviews/backend/route.ts`: Hono 라우터 등록
    - `GET /api/places/:place_id/reviews`
  - [ ] `src/features/reviews/lib/dto.ts`: 스키마 재노출

- [ ] **Hono App 통합**
  - [ ] `src/backend/hono/app.ts`에서 라우터 등록
    ```typescript
    import { registerPlacesRoutes } from '@/features/places/backend/route';
    import { registerReviewsRoutes } from '@/features/reviews/backend/route';

    registerPlacesRoutes(app);
    registerReviewsRoutes(app);
    ```

### 9.3 Frontend Implementation

- [ ] **Zustand Store**
  - [ ] `src/stores/useAppStore.ts`: 모달/지도 상태 관리

- [ ] **React Query Hooks**
  - [ ] `src/features/places/hooks/usePlaces.ts`
    - `usePlacesWithReviews()`
    - `useSearchPlaces(query, enabled)`
    - `usePlaceByNaverId(naverPlaceId)`
  - [ ] `src/features/reviews/hooks/useReviews.ts`
    - `useReviews(placeId)`

- [ ] **Components**
  - [ ] `src/features/places/components/SearchBar.tsx`: 검색 폼
  - [ ] `src/features/places/components/NaverMap.tsx`: 네이버 지도 래퍼
  - [ ] `src/features/places/components/PlaceMarker.tsx`: 마커 컴포넌트
  - [ ] `src/features/places/components/SearchResultsModal.tsx`: 검색 결과 모달
  - [ ] `src/features/places/components/SearchResultItem.tsx`: 검색 결과 항목
  - [ ] `src/features/places/components/PlaceDetailModal.tsx`: 장소 상세 모달
  - [ ] `src/features/places/components/PlaceInfo.tsx`: 장소 정보
  - [ ] `src/features/reviews/components/ReviewStats.tsx`: 평균 별점 표시
  - [ ] `src/features/reviews/components/ReviewList.tsx`: 리뷰 목록
  - [ ] `src/features/reviews/components/ReviewItem.tsx`: 리뷰 항목

- [ ] **네이버 SDK 설정**
  - [ ] `src/app/layout.tsx`: Script 컴포넌트로 네이버 지도 SDK 로드
    ```tsx
    <Script
      strategy="afterInteractive"
      src={`https://oapi.map.naver.com/openapi/v3/maps.js?ncpKeyId=${process.env.NEXT_PUBLIC_NAVER_CLIENT_ID}`}
    />
    ```

- [ ] **메인 페이지**
  - [ ] `src/app/page.tsx`: 컴포넌트 통합

### 9.4 Testing

- [ ] Backend Unit Tests
  - [ ] `src/features/places/backend/__tests__/service.test.ts`
  - [ ] `src/features/reviews/backend/__tests__/service.test.ts`

- [ ] Frontend Unit Tests
  - [ ] `src/features/places/hooks/__tests__/usePlaces.test.ts`
  - [ ] `src/stores/__tests__/useAppStore.test.ts`

- [ ] Integration Tests
  - [ ] `src/features/places/backend/__tests__/route.test.ts`

---

## 10. QA Sheet (Presentation Layer)

### 10.1 검색 기능

| 테스트 케이스 | 입력 | 예상 결과 | 통과 여부 |
|--------------|------|-----------|----------|
| 정상 검색 | "강남 맛집" | 검색 결과 모달 표시, 리스트 표시 | [ ] |
| 빈 검색어 | "" | "검색어를 입력해주세요" 에러 표시 | [ ] |
| 검색 결과 없음 | "존재하지않는키워드12345" | "검색 결과가 없습니다" 표시 | [ ] |
| 네이버 API 오류 | - | "검색에 실패했습니다. 다시 시도해주세요" 표시 | [ ] |

### 10.2 검색 결과 모달

| 테스트 케이스 | 동작 | 예상 결과 | 통과 여부 |
|--------------|------|-----------|----------|
| 리스트 스크롤 | 스크롤 다운 | 결과 5개 모두 표시 | [ ] |
| 항목 선택 | 첫 번째 항목 클릭 | 지도 마커 강조 표시 | [ ] |
| 장소 세부 정보 진입 | "장소 세부 정보" 버튼 클릭 | 장소 상세 모달 표시 | [ ] |
| 모달 외부 클릭 | 모달 외부 영역 클릭 | 모달 닫기, 메인 지도로 복귀 | [ ] |

### 10.3 장소 상세 모달

| 테스트 케이스 | 동작 | 예상 결과 | 통과 여부 |
|--------------|------|-----------|----------|
| 장소 정보 표시 | 모달 열기 | 업체명, 주소, 전화번호 표시 | [ ] |
| 평균 별점 표시 | - | ★★★★☆ 형태로 표시 (4.5점 예시) | [ ] |
| 리뷰 개수 표시 | - | "총 10개의 리뷰" 표시 | [ ] |
| 리뷰 목록 표시 | - | 작성자, 별점, 날짜, 내용 표시 | [ ] |
| 리뷰 정렬 | - | 최신순 정렬 (created_at DESC) | [ ] |
| 리뷰 없음 | 리뷰 0건 | "아직 작성된 리뷰가 없습니다" 표시 | [ ] |
| 모달 닫기 (검색 진입) | 닫기 버튼 클릭 | 검색 결과 모달로 복귀 | [ ] |
| 모달 닫기 (마커 진입) | 닫기 버튼 클릭 | 메인 지도로 복귀 | [ ] |

### 10.4 지도 기능

| 테스트 케이스 | 동작 | 예상 결과 | 통과 여부 |
|--------------|------|-----------|----------|
| 초기 지도 표시 | 페이지 로드 | 강남역 중심으로 지도 표시 | [ ] |
| 마커 표시 | - | 리뷰가 있는 장소에 커스텀 마커 표시 | [ ] |
| 마커 클릭 | 마커 클릭 | 장소 상세 모달 표시 | [ ] |
| 마커 강조 | 검색 결과 항목 선택 | 해당 마커 강조 표시 (색상/크기 변경) | [ ] |
| 지도 확대/축소 | 줌 컨트롤 클릭 | 정상 작동 | [ ] |
| 지도 이동 | 드래그 | 정상 작동 | [ ] |

### 10.5 반응형 디자인

| 테스트 케이스 | 화면 크기 | 예상 결과 | 통과 여부 |
|--------------|----------|-----------|----------|
| 데스크톱 (1920x1080) | - | 레이아웃 정상 표시 | [ ] |
| 태블릿 (768x1024) | - | 레이아웃 정상 표시 | [ ] |
| 모바일 (375x667) | - | 레이아웃 정상 표시 | [ ] |

---

## 11. Potential Improvements

### 11.1 성능 최적화
- React Query의 Prefetching: 검색 결과 항목 hover 시 장소 상세 정보 미리 가져오기
- Virtual Scrolling: 검색 결과/리뷰 목록이 많을 경우 `@tanstack/react-virtual` 적용
- Image Lazy Loading: 마커 아이콘 이미지 최적화

### 11.2 UX 개선
- 검색 자동완성: 네이버 자동완성 API 연동
- 검색 히스토리: 로컬 스토리지 활용
- 스켈레톤 로딩: 데이터 로딩 중 스켈레톤 UI 표시
- 마커 클러스터링: 지도 축소 시 마커를 그룹화

### 11.3 확장 가능성
- 리뷰 작성 기능 (UC-002)
- 리뷰 수정/삭제 기능
- 사용자 인증 (리뷰 작성자 검증)
- 이미지 업로드 (리뷰 첨부 이미지)

---

## 12. 참고 문서

- [UC-001 Specification](./spec.md)
- [State Management Design](/docs/state-management.md)
- [Database Schema](/docs/database.md)
- [Naver Map SDK Guide](/docs/naver_map_SDK.md)
- [AGENTS.md](/.ruler/AGENTS.md)
</file>

<file path="001/spec.md">
# UC-001: 장소 검색 및 정보 확인

## Primary Actor
일반 사용자 (음식점을 찾고 리뷰를 참고하는 사용자)

## Precondition
- 사용자가 메인 페이지에 접속하여 지도가 정상적으로 로드됨
- 네이버 지도 SDK가 초기화되어 강남역 중심으로 표시됨
- 상단 검색 바가 활성화되어 입력 가능한 상태

## Trigger
사용자가 상단 검색 바에 음식점명 또는 지역명을 입력하고 검색 버튼 클릭 또는 엔터 키 입력

## Main Scenario

### 1. 검색 실행
1. 사용자가 검색 바에 키워드 입력 (예: "강남 맛집")
2. 검색 버튼 클릭 또는 엔터 키 입력
3. 시스템이 네이버 장소 검색 API 호출
4. 장소 검색 결과 모달창 표시

### 2. 검색 결과 확인
1. 시스템이 검색 결과를 스크롤 가능한 리스트 형태로 표시
2. 각 리스트 항목에 업체명, 주소 등 기본 정보 표시
3. 사용자가 리스트를 스크롤하며 원하는 업체 탐색

### 3. 검색 결과 항목 선택
1. 사용자가 리스트에서 특정 업체 항목 클릭
2. 시스템이 해당 장소의 좌표(latitude, longitude) 확인
3. 지도상에서 해당 장소의 마커를 강조 표시
4. 모달창은 계속 표시 상태 유지

### 4. 장소 세부 정보 진입
1. 사용자가 선택한 항목 하단의 "장소 세부 정보" 버튼 클릭
2. 시스템이 다음 작업 수행:
   - places 테이블에서 naver_place_id 조회
   - 데이터가 없으면 places 테이블에 INSERT 후 place_id 획득
   - reviews 테이블에서 place_id로 리뷰 목록 조회
   - 평균 별점(AVG(rating)) 및 리뷰 개수(COUNT(*)) 계산
3. 장소 세부 정보 모달창 표시

### 5. 장소 세부 정보 확인
1. 시스템이 장소 세부 정보 모달에 다음 정보 표시:
   - 업체명, 주소, 전화번호
   - 평균 별점 (★ 5개 중 노란색 표시)
   - 총 리뷰 개수
   - 리뷰 목록 (작성자, 별점, 게시일자, 내용)
2. 사용자가 리뷰 정보 확인

### 6. 모달 닫기 및 복귀
1. 사용자가 모달 외부 클릭 또는 닫기 버튼 클릭
2. 시스템이 장소 세부 정보 모달 닫기
3. 직전 상태인 장소 검색 결과 모달로 복귀
4. (선택) 사용자가 검색 결과 모달도 닫으면 메인 지도 화면으로 복귀

## Edge Cases

### EC-001: 검색 결과 없음
- **상황**: 입력한 키워드로 검색 결과가 0건
- **처리**: 장소 검색 결과 모달에 "검색 결과가 없습니다" 안내 문구 표시

### EC-002: 네이버 API 호출 실패
- **상황**: 네트워크 오류 또는 API 장애로 검색 실패
- **처리**: 에러 메시지 표시 ("검색에 실패했습니다. 다시 시도해주세요")

### EC-003: 리뷰 데이터 없음
- **상황**: 장소는 존재하지만 작성된 리뷰가 0건
- **처리**:
  - 평균 별점: 0 또는 "-" 표시
  - 총 리뷰 개수: 0 표시
  - 리뷰 목록: "아직 작성된 리뷰가 없습니다" 안내 문구 표시

### EC-004: 데이터베이스 조회 실패
- **상황**: Supabase 연결 오류 또는 쿼리 실패
- **처리**: 에러 메시지 표시 ("정보를 불러오는 중 오류가 발생했습니다")

### EC-005: 빈 검색어 입력
- **상황**: 사용자가 검색어를 입력하지 않고 검색 시도
- **처리**: 검색 실행 차단 또는 "검색어를 입력해주세요" 안내 표시

## Business Rules

### BR-001: 장소 데이터 캐싱
- places 테이블에 naver_place_id가 존재하면 기존 데이터 사용
- 존재하지 않으면 네이버 API 데이터 기반으로 INSERT
- 중복 저장 방지를 위해 naver_place_id는 UNIQUE 제약조건 적용

### BR-002: 평균 별점 계산
- 리뷰가 1건 이상일 때: AVG(rating) 소수점 첫째 자리까지 표시
- 리뷰가 0건일 때: 0 또는 "-" 표시

### BR-003: 리뷰 정렬
- 리뷰 목록은 작성일시(created_at) 기준 내림차순 정렬
- 최신 리뷰가 상단에 표시됨

### BR-004: 모달 네비게이션
- 장소 세부 정보 모달 닫기 시 직전 상태(검색 결과 모달)로 복귀
- 검색 결과 모달 닫기 시 메인 지도 화면으로 복귀
- 모달 외부 클릭 시 해당 모달만 닫힘

### BR-005: 마커 강조
- 검색 결과에서 항목 선택 시 지도상의 해당 마커 강조 표시
- 강조 표시는 시각적으로 구분 가능한 스타일 적용 (예: 색상 변경, 크기 확대)

## Sequence Diagram

```plantuml
@startuml
actor User
participant FE as "Frontend"
participant BE as "Backend API"
database DB as "Supabase"

User -> FE: 검색어 입력 후 검색 실행
FE -> BE: GET /api/search?query={keyword}
BE -> BE: 네이버 장소 검색 API 호출
BE --> FE: 검색 결과 반환
FE -> FE: 장소 검색 결과 모달 표시

User -> FE: 리스트 항목 선택
FE -> FE: 지도 마커 강조 표시

User -> FE: "장소 세부 정보" 버튼 클릭
FE -> BE: GET /api/places/:naver_place_id
BE -> DB: SELECT * FROM places WHERE naver_place_id = :id
alt 장소 데이터 없음
  BE -> DB: INSERT INTO places (naver_place_id, name, address, phone, latitude, longitude) VALUES (...)
  DB --> BE: place_id 반환
end
DB --> BE: place 데이터 반환
BE --> FE: place 데이터 반환

FE -> BE: GET /api/places/:place_id/reviews
BE -> DB: SELECT * FROM reviews WHERE place_id = :place_id ORDER BY created_at DESC
DB --> BE: 리뷰 목록 반환
BE -> DB: SELECT AVG(rating), COUNT(*) FROM reviews WHERE place_id = :place_id
DB --> BE: 평균 별점, 리뷰 개수 반환
BE --> FE: 리뷰 데이터 + 통계 반환

FE -> FE: 장소 세부 정보 모달 표시
FE -> User: 업체 정보, 평균 별점, 리뷰 목록 표시

User -> FE: 모달 닫기 (외부 클릭)
FE -> FE: 장소 세부 정보 모달 닫기
FE -> User: 장소 검색 결과 모달 복귀
@enduml
```
</file>

<file path="002/plan.md">
# UC-002: 지도 마커를 통한 정보 확인 - Implementation Plan

## 1. Feature Overview

### 1.1 기능 개요
UC-002는 사용자가 지도에서 리뷰가 존재하는 음식점을 마커로 확인하고, 마커 클릭 시 상세 정보를 조회하는 기능입니다.

**핵심 플로우:**
1. 메인 페이지 진입 시 네이버 지도 초기화 (강남역 중심)
2. 리뷰가 존재하는 장소 목록 조회 및 지도에 커스텀 마커 표시
3. 사용자가 마커 클릭 시 장소 상세 정보 모달 표시
4. 장소 정보, 평균 별점, 리뷰 목록 렌더링

### 1.2 비즈니스 규칙
- 마커는 리뷰가 1개 이상 존재하는 장소에만 표시
- 마커 클릭 시마다 최신 데이터를 API로 조회 (캐싱 미적용)
- 평균 별점은 소수점 첫째 자리까지 표시
- 리뷰는 최신순 정렬 (`created_at DESC`)

---

## 2. Technical Architecture

### 2.1 아키텍처 다이어그램

```mermaid
graph TB
    subgraph "Frontend Layer"
        A[MapPage] --> B[NaverMapContainer]
        B --> C[PlaceMarker]
        A --> D[PlaceDetailModal]
        D --> E[ReviewList]
        D --> F[ReviewWriteButton]
    end

    subgraph "State Management"
        G[Zustand Store] --> H[mapCenter]
        G --> I[highlightedMarkerId]
        G --> J[modalState]

        K[React Query] --> L[usePlacesWithReviews]
        K --> M[usePlaceReviews]
    end

    subgraph "Backend Layer"
        N[Hono API] --> O[GET /api/places/with-reviews]
        N --> P[GET /api/places/:placeId/reviews]

        O --> Q[PlacesService.getPlacesWithReviews]
        P --> R[PlacesService.getPlaceReviewsById]

        Q --> S[(Supabase places + reviews)]
        R --> S
    end

    subgraph "External Services"
        T[Naver Maps SDK] --> B
    end

    B --> G
    C --> G
    A --> K
    D --> K

    L --> N
    M --> N

    T -.마커 렌더링.-> C
    C -.클릭 이벤트.-> G
    G -.모달 열기.-> D
```

### 2.2 컴포넌트 계층 구조

```
src/
├── app/
│   └── page.tsx                              # 메인 페이지 (지도 + 모달)
├── features/
│   ├── map/
│   │   ├── components/
│   │   │   ├── NaverMapContainer.tsx         # 네이버 지도 래퍼
│   │   │   ├── PlaceMarker.tsx               # 커스텀 마커 컴포넌트
│   │   │   └── MapControls.tsx               # 지도 컨트롤 UI
│   │   ├── hooks/
│   │   │   ├── useNaverMap.ts                # 지도 초기화 훅
│   │   │   └── useMapMarkers.ts              # 마커 관리 훅
│   │   └── constants/
│   │       └── map.ts                        # 지도 기본 설정
│   ├── places/
│   │   ├── components/
│   │   │   ├── PlaceDetailModal.tsx          # 장소 상세 모달
│   │   │   ├── PlaceInfo.tsx                 # 장소 기본 정보
│   │   │   └── ReviewStats.tsx               # 평균 별점 + 리뷰 개수
│   │   ├── hooks/
│   │   │   ├── usePlacesWithReviews.ts       # 리뷰 있는 장소 목록 조회
│   │   │   └── usePlaceReviews.ts            # 특정 장소 리뷰 조회
│   │   ├── backend/
│   │   │   ├── route.ts                      # Hono 라우터
│   │   │   ├── service.ts                    # Supabase 쿼리
│   │   │   ├── schema.ts                     # Zod 스키마
│   │   │   └── error.ts                      # 에러 코드 정의
│   │   └── lib/
│   │       └── dto.ts                        # 클라이언트 타입 재노출
│   └── reviews/
│       └── components/
│           ├── ReviewList.tsx                # 리뷰 목록
│           └── ReviewItem.tsx                # 개별 리뷰
└── stores/
    └── useAppStore.ts                        # Zustand 전역 상태
```

### 2.3 상태 관리 아키텍처

#### Zustand Store (전역 UI 상태)
```typescript
interface AppState {
  // Modal 관리
  modalState: 'closed' | 'search-results' | 'place-detail' | 'review-write'
  modalHistory: ModalHistoryItem[]
  openModal: (type: ModalState, data?: any) => void
  closeModal: () => void
  goBackModal: () => void

  // Map 관리
  highlightedMarkerId: string | null
  mapCenter: { lat: number; lng: number }
  setHighlightedMarker: (id: string | null) => void
  setMapCenter: (lat: number, lng: number) => void

  // UI 상태
  status: 'idle' | 'loading' | 'success' | 'error'
  error: string | null
}
```

#### React Query (서버 상태)
```typescript
// 리뷰가 있는 장소 목록 (지도 마커용)
usePlacesWithReviews() → Place[]

// 특정 장소의 리뷰 및 통계
usePlaceReviews(placeId) → {
  place: Place
  reviews: Review[]
  avgRating: number
  reviewCount: number
}
```

---

## 3. Implementation Plan

### 3.1 Backend API Implementation

#### 3.1.1 GET /api/places/with-reviews

**파일:** `src/features/places/backend/route.ts`

```typescript
import type { Hono } from 'hono';
import { getSupabase, getLogger, type AppEnv } from '@/backend/hono/context';
import { respond } from '@/backend/http/response';
import { getPlacesWithReviews } from './service';

export const registerPlacesRoutes = (app: Hono<AppEnv>) => {
  // 리뷰가 존재하는 장소 목록 조회
  app.get('/places/with-reviews', async (c) => {
    const supabase = getSupabase(c);
    const logger = getLogger(c);

    const result = await getPlacesWithReviews(supabase);

    if (!result.ok) {
      logger.error('Failed to fetch places with reviews', result.error.message);
    }

    return respond(c, result);
  });

  // 특정 장소의 리뷰 조회
  app.get('/places/:placeId/reviews', async (c) => {
    const placeId = c.req.param('placeId');
    const supabase = getSupabase(c);
    const logger = getLogger(c);

    const result = await getPlaceReviewsById(supabase, placeId);

    if (!result.ok) {
      logger.error(`Failed to fetch reviews for place ${placeId}`, result.error.message);
    }

    return respond(c, result);
  });
};
```

**파일:** `src/features/places/backend/service.ts`

```typescript
import type { SupabaseClient } from '@supabase/supabase-js';
import { failure, success, type HandlerResult } from '@/backend/http/response';
import { PlacesWithReviewsResponseSchema, PlaceReviewsResponseSchema } from './schema';
import { placesErrorCodes, type PlacesServiceError } from './error';

export const getPlacesWithReviews = async (
  client: SupabaseClient,
): Promise<HandlerResult<PlacesWithReviewsResponse, PlacesServiceError, unknown>> => {
  const { data, error } = await client
    .from('places')
    .select('id, naver_place_id, name, latitude, longitude')
    .in('id',
      client.from('reviews').select('place_id')
    );

  if (error) {
    return failure(500, placesErrorCodes.fetchError, error.message);
  }

  const parsed = PlacesWithReviewsResponseSchema.safeParse(data);

  if (!parsed.success) {
    return failure(
      500,
      placesErrorCodes.validationError,
      'Places data validation failed',
      parsed.error.format()
    );
  }

  return success(parsed.data);
};

export const getPlaceReviewsById = async (
  client: SupabaseClient,
  placeId: string,
): Promise<HandlerResult<PlaceReviewsResponse, PlacesServiceError, unknown>> => {
  // 장소 정보 조회
  const { data: place, error: placeError } = await client
    .from('places')
    .select('id, naver_place_id, name, address, phone, latitude, longitude')
    .eq('id', placeId)
    .single();

  if (placeError) {
    return failure(500, placesErrorCodes.fetchError, placeError.message);
  }

  if (!place) {
    return failure(404, placesErrorCodes.notFound, 'Place not found');
  }

  // 리뷰 목록 조회
  const { data: reviews, error: reviewsError } = await client
    .from('reviews')
    .select('id, author_name, rating, content, created_at')
    .eq('place_id', placeId)
    .order('created_at', { ascending: false });

  if (reviewsError) {
    return failure(500, placesErrorCodes.fetchError, reviewsError.message);
  }

  // 평균 별점 및 리뷰 개수 계산
  const { data: stats, error: statsError } = await client
    .from('reviews')
    .select('rating')
    .eq('place_id', placeId);

  if (statsError) {
    return failure(500, placesErrorCodes.fetchError, statsError.message);
  }

  const avgRating = stats.length > 0
    ? stats.reduce((sum, r) => sum + r.rating, 0) / stats.length
    : 0;
  const reviewCount = stats.length;

  const responseData = {
    place,
    reviews: reviews || [],
    avgRating: Math.round(avgRating * 10) / 10, // 소수점 첫째자리
    reviewCount,
  };

  const parsed = PlaceReviewsResponseSchema.safeParse(responseData);

  if (!parsed.success) {
    return failure(
      500,
      placesErrorCodes.validationError,
      'Place reviews data validation failed',
      parsed.error.format()
    );
  }

  return success(parsed.data);
};
```

**파일:** `src/features/places/backend/schema.ts`

```typescript
import { z } from 'zod';

export const PlaceSchema = z.object({
  id: z.string().uuid(),
  naver_place_id: z.string(),
  name: z.string(),
  address: z.string(),
  phone: z.string().nullable(),
  latitude: z.number(),
  longitude: z.number(),
});

export const PlaceMarkerSchema = z.object({
  id: z.string().uuid(),
  naver_place_id: z.string(),
  name: z.string(),
  latitude: z.number(),
  longitude: z.number(),
});

export const ReviewSchema = z.object({
  id: z.string().uuid(),
  author_name: z.string(),
  rating: z.number().int().min(1).max(5),
  content: z.string(),
  created_at: z.string(),
});

export const PlacesWithReviewsResponseSchema = z.array(PlaceMarkerSchema);

export const PlaceReviewsResponseSchema = z.object({
  place: PlaceSchema,
  reviews: z.array(ReviewSchema),
  avgRating: z.number(),
  reviewCount: z.number().int(),
});

export type Place = z.infer<typeof PlaceSchema>;
export type PlaceMarker = z.infer<typeof PlaceMarkerSchema>;
export type Review = z.infer<typeof ReviewSchema>;
export type PlacesWithReviewsResponse = z.infer<typeof PlacesWithReviewsResponseSchema>;
export type PlaceReviewsResponse = z.infer<typeof PlaceReviewsResponseSchema>;
```

**파일:** `src/features/places/backend/error.ts`

```typescript
export const placesErrorCodes = {
  fetchError: 'PLACES_FETCH_ERROR',
  notFound: 'PLACE_NOT_FOUND',
  validationError: 'PLACES_VALIDATION_ERROR',
} as const;

export type PlacesServiceError = typeof placesErrorCodes[keyof typeof placesErrorCodes];
```

**파일:** `src/features/places/lib/dto.ts`

```typescript
export {
  PlaceSchema,
  PlaceMarkerSchema,
  ReviewSchema,
  PlacesWithReviewsResponseSchema,
  PlaceReviewsResponseSchema,
  type Place,
  type PlaceMarker,
  type Review,
  type PlacesWithReviewsResponse,
  type PlaceReviewsResponse,
} from '@/features/places/backend/schema';
```

#### 3.1.2 Hono 앱에 라우터 등록

**파일:** `src/backend/hono/app.ts`

```typescript
// 기존 코드에 추가
import { registerPlacesRoutes } from '@/features/places/backend/route';

export const createHonoApp = () => {
  // ... 기존 미들웨어 설정 ...

  registerPlacesRoutes(app);
  // registerExampleRoutes(app); // 기존 예시 라우터

  return app;
};
```

### 3.2 Frontend Implementation

#### 3.2.1 React Query Hooks

**파일:** `src/features/places/hooks/usePlacesWithReviews.ts`

```typescript
'use client';

import { useQuery } from '@tanstack/react-query';
import { apiClient, extractApiErrorMessage } from '@/lib/remote/api-client';
import { PlacesWithReviewsResponseSchema } from '@/features/places/lib/dto';

const fetchPlacesWithReviews = async () => {
  try {
    const { data } = await apiClient.get('/api/places/with-reviews');
    return PlacesWithReviewsResponseSchema.parse(data);
  } catch (error) {
    const message = extractApiErrorMessage(error, 'Failed to fetch places with reviews.');
    throw new Error(message);
  }
};

export const usePlacesWithReviews = () =>
  useQuery({
    queryKey: ['places', 'with-reviews'],
    queryFn: fetchPlacesWithReviews,
    staleTime: 5 * 60 * 1000, // 5분
    gcTime: 10 * 60 * 1000,   // 10분
  });
```

**파일:** `src/features/places/hooks/usePlaceReviews.ts`

```typescript
'use client';

import { useQuery } from '@tanstack/react-query';
import { apiClient, extractApiErrorMessage } from '@/lib/remote/api-client';
import { PlaceReviewsResponseSchema } from '@/features/places/lib/dto';

const fetchPlaceReviews = async (placeId: string) => {
  try {
    const { data } = await apiClient.get(`/api/places/${placeId}/reviews`);
    return PlaceReviewsResponseSchema.parse(data);
  } catch (error) {
    const message = extractApiErrorMessage(error, 'Failed to fetch place reviews.');
    throw new Error(message);
  }
};

export const usePlaceReviews = (placeId: string) =>
  useQuery({
    queryKey: ['places', placeId, 'reviews'],
    queryFn: () => fetchPlaceReviews(placeId),
    enabled: Boolean(placeId),
    staleTime: 30 * 1000,     // 30초
    gcTime: 2 * 60 * 1000,    // 2분
  });
```

#### 3.2.2 Zustand Store

**파일:** `src/stores/useAppStore.ts`

```typescript
'use client';

import { create } from 'zustand';

type ModalState = 'closed' | 'search-results' | 'place-detail' | 'review-write';

interface ModalHistoryItem {
  type: Exclude<ModalState, 'closed'>;
  data?: {
    placeId?: string;
    naverPlaceId?: string;
    searchQuery?: string;
  };
}

interface AppState {
  // Modal 관리
  modalState: ModalState;
  modalHistory: ModalHistoryItem[];
  openModal: (type: Exclude<ModalState, 'closed'>, data?: any) => void;
  closeModal: () => void;
  goBackModal: () => void;

  // Map 관리
  highlightedMarkerId: string | null;
  mapCenter: { lat: number; lng: number };
  setHighlightedMarker: (id: string | null) => void;
  setMapCenter: (lat: number, lng: number) => void;

  // UI 상태
  status: 'idle' | 'loading' | 'success' | 'error';
  error: string | null;
  setStatus: (status: 'idle' | 'loading' | 'success' | 'error') => void;
  setError: (error: string | null) => void;
}

export const useAppStore = create<AppState>((set, get) => ({
  modalState: 'closed',
  modalHistory: [],
  highlightedMarkerId: null,
  mapCenter: { lat: 37.498095, lng: 127.027610 }, // 강남역
  status: 'idle',
  error: null,

  openModal: (type, data) =>
    set((state) => ({
      modalState: type,
      modalHistory: [...state.modalHistory, { type, data }],
    })),

  closeModal: () =>
    set({
      modalState: 'closed',
      modalHistory: [],
    }),

  goBackModal: () =>
    set((state) => {
      const newHistory = [...state.modalHistory];
      newHistory.pop();
      const prevModal = newHistory[newHistory.length - 1];

      return {
        modalState: prevModal?.type || 'closed',
        modalHistory: newHistory,
      };
    }),

  setHighlightedMarker: (id) => set({ highlightedMarkerId: id }),
  setMapCenter: (lat, lng) => set({ mapCenter: { lat, lng } }),
  setStatus: (status) => set({ status }),
  setError: (error) => set({ error }),
}));
```

#### 3.2.3 Map Components

**파일:** `src/features/map/constants/map.ts`

```typescript
export const DEFAULT_MAP_CENTER = {
  lat: 37.498095,
  lng: 127.027610,
} as const; // 강남역

export const DEFAULT_MAP_ZOOM = 15;

export const MARKER_ICON = {
  default: {
    content: '<div class="custom-marker">📍</div>',
    size: new naver.maps.Size(32, 32),
    anchor: new naver.maps.Point(16, 32),
  },
  highlighted: {
    content: '<div class="custom-marker-highlighted">📍</div>',
    size: new naver.maps.Size(40, 40),
    anchor: new naver.maps.Point(20, 40),
  },
};
```

**파일:** `src/features/map/hooks/useNaverMap.ts`

```typescript
'use client';

import { useEffect, useRef } from 'react';
import { DEFAULT_MAP_CENTER, DEFAULT_MAP_ZOOM } from '@/features/map/constants/map';

interface UseNaverMapOptions {
  center?: { lat: number; lng: number };
  zoom?: number;
}

export const useNaverMap = (options: UseNaverMapOptions = {}) => {
  const mapRef = useRef<HTMLDivElement>(null);
  const naverMapRef = useRef<naver.maps.Map | null>(null);

  useEffect(() => {
    if (!mapRef.current || !window.naver) return;

    const mapOptions: naver.maps.MapOptions = {
      center: new naver.maps.LatLng(
        options.center?.lat || DEFAULT_MAP_CENTER.lat,
        options.center?.lng || DEFAULT_MAP_CENTER.lng
      ),
      zoom: options.zoom || DEFAULT_MAP_ZOOM,
      zoomControl: true,
      zoomControlOptions: {
        style: naver.maps.ZoomControlStyle.SMALL,
        position: naver.maps.Position.TOP_RIGHT,
      },
    };

    const map = new naver.maps.Map(mapRef.current, mapOptions);
    naverMapRef.current = map;

    return () => {
      naverMapRef.current?.destroy();
    };
  }, [options.center?.lat, options.center?.lng, options.zoom]);

  return { mapRef, naverMapRef };
};
```

**파일:** `src/features/map/components/NaverMapContainer.tsx`

```typescript
'use client';

import { useEffect } from 'react';
import { useNaverMap } from '@/features/map/hooks/useNaverMap';
import { usePlacesWithReviews } from '@/features/places/hooks/usePlacesWithReviews';
import { useAppStore } from '@/stores/useAppStore';
import { PlaceMarker } from './PlaceMarker';

interface NaverMapContainerProps {
  width?: string;
  height?: string;
}

export const NaverMapContainer = ({
  width = '100%',
  height = '100vh',
}: NaverMapContainerProps) => {
  const { mapRef, naverMapRef } = useNaverMap();
  const { data: places, isLoading, error } = usePlacesWithReviews();
  const mapCenter = useAppStore((state) => state.mapCenter);
  const setStatus = useAppStore((state) => state.setStatus);
  const setError = useAppStore((state) => state.setError);

  useEffect(() => {
    if (isLoading) {
      setStatus('loading');
    } else if (error) {
      setStatus('error');
      setError(error.message);
    } else if (places) {
      setStatus('success');
    }
  }, [isLoading, error, places, setStatus, setError]);

  useEffect(() => {
    if (naverMapRef.current && mapCenter) {
      const center = new naver.maps.LatLng(mapCenter.lat, mapCenter.lng);
      naverMapRef.current.setCenter(center);
    }
  }, [mapCenter]);

  return (
    <div className="relative" style={{ width, height }}>
      <div ref={mapRef} className="w-full h-full" />
      {naverMapRef.current && places && (
        <>
          {places.map((place) => (
            <PlaceMarker
              key={place.id}
              map={naverMapRef.current!}
              place={place}
            />
          ))}
        </>
      )}
    </div>
  );
};
```

**파일:** `src/features/map/components/PlaceMarker.tsx`

```typescript
'use client';

import { useEffect, useRef, memo } from 'react';
import { useAppStore } from '@/stores/useAppStore';
import type { PlaceMarker as PlaceMarkerType } from '@/features/places/lib/dto';

interface PlaceMarkerProps {
  map: naver.maps.Map;
  place: PlaceMarkerType;
}

export const PlaceMarker = memo(({ map, place }: PlaceMarkerProps) => {
  const markerRef = useRef<naver.maps.Marker | null>(null);
  const highlightedMarkerId = useAppStore((state) => state.highlightedMarkerId);
  const openModal = useAppStore((state) => state.openModal);
  const setHighlightedMarker = useAppStore((state) => state.setHighlightedMarker);

  const isHighlighted = highlightedMarkerId === place.id;

  useEffect(() => {
    if (!map) return;

    const marker = new naver.maps.Marker({
      position: new naver.maps.LatLng(place.latitude, place.longitude),
      map: map,
      title: place.name,
      icon: {
        content: isHighlighted
          ? '<div class="w-10 h-10 text-3xl">📍</div>'
          : '<div class="w-8 h-8 text-2xl">📍</div>',
      },
    });

    const clickListener = naver.maps.Event.addListener(marker, 'click', () => {
      setHighlightedMarker(place.id);
      openModal('place-detail', { placeId: place.id });
    });

    markerRef.current = marker;

    return () => {
      naver.maps.Event.removeListener(clickListener);
      marker.setMap(null);
    };
  }, [map, place, isHighlighted, openModal, setHighlightedMarker]);

  return null;
}, (prevProps, nextProps) => {
  return prevProps.place.id === nextProps.place.id;
});

PlaceMarker.displayName = 'PlaceMarker';
```

#### 3.2.4 Place Detail Components

**파일:** `src/features/places/components/PlaceDetailModal.tsx`

```typescript
'use client';

import { useAppStore } from '@/stores/useAppStore';
import { usePlaceReviews } from '@/features/places/hooks/usePlaceReviews';
import { Dialog, DialogContent, DialogHeader, DialogTitle } from '@/components/ui/dialog';
import { Button } from '@/components/ui/button';
import { Loader2 } from 'lucide-react';
import { PlaceInfo } from './PlaceInfo';
import { ReviewStats } from './ReviewStats';
import { ReviewList } from '@/features/reviews/components/ReviewList';

export const PlaceDetailModal = () => {
  const modalState = useAppStore((state) => state.modalState);
  const modalHistory = useAppStore((state) => state.modalHistory);
  const closeModal = useAppStore((state) => state.closeModal);
  const goBackModal = useAppStore((state) => state.goBackModal);
  const openModal = useAppStore((state) => state.openModal);

  const isOpen = modalState === 'place-detail';
  const currentModalData = modalHistory[modalHistory.length - 1];
  const placeId = currentModalData?.data?.placeId || '';

  const { data, isLoading, error } = usePlaceReviews(placeId);

  const handleClose = () => {
    const prevModal = modalHistory[modalHistory.length - 2];
    if (prevModal) {
      goBackModal();
    } else {
      closeModal();
    }
  };

  const handleReviewWrite = () => {
    openModal('review-write', { placeId });
  };

  return (
    <Dialog open={isOpen} onOpenChange={handleClose}>
      <DialogContent className="max-w-2xl max-h-[80vh] overflow-y-auto">
        <DialogHeader>
          <DialogTitle>장소 상세 정보</DialogTitle>
        </DialogHeader>

        {isLoading && (
          <div className="flex justify-center items-center py-8">
            <Loader2 className="h-8 w-8 animate-spin" />
          </div>
        )}

        {error && (
          <div className="text-red-500 text-center py-8">
            {error.message}
          </div>
        )}

        {data && (
          <div className="space-y-6">
            <PlaceInfo place={data.place} />
            <ReviewStats
              avgRating={data.avgRating}
              reviewCount={data.reviewCount}
            />
            <div className="flex justify-end">
              <Button onClick={handleReviewWrite}>
                리뷰 작성하기
              </Button>
            </div>
            <ReviewList reviews={data.reviews} />
          </div>
        )}
      </DialogContent>
    </Dialog>
  );
};
```

**파일:** `src/features/places/components/PlaceInfo.tsx`

```typescript
'use client';

import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { MapPin, Phone } from 'lucide-react';
import type { Place } from '@/features/places/lib/dto';

interface PlaceInfoProps {
  place: Place;
}

export const PlaceInfo = ({ place }: PlaceInfoProps) => {
  return (
    <Card>
      <CardHeader>
        <CardTitle>{place.name}</CardTitle>
      </CardHeader>
      <CardContent className="space-y-2">
        <div className="flex items-start gap-2">
          <MapPin className="h-5 w-5 mt-0.5 text-muted-foreground" />
          <span className="text-sm">{place.address}</span>
        </div>
        {place.phone && (
          <div className="flex items-center gap-2">
            <Phone className="h-5 w-5 text-muted-foreground" />
            <span className="text-sm">{place.phone}</span>
          </div>
        )}
      </CardContent>
    </Card>
  );
};
```

**파일:** `src/features/places/components/ReviewStats.tsx`

```typescript
'use client';

import { Star } from 'lucide-react';
import { Card, CardContent } from '@/components/ui/card';

interface ReviewStatsProps {
  avgRating: number;
  reviewCount: number;
}

export const ReviewStats = ({ avgRating, reviewCount }: ReviewStatsProps) => {
  const fullStars = Math.floor(avgRating);
  const hasHalfStar = avgRating % 1 >= 0.5;

  return (
    <Card>
      <CardContent className="pt-6">
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-2">
            <div className="flex">
              {[...Array(5)].map((_, i) => (
                <Star
                  key={i}
                  className={`h-6 w-6 ${
                    i < fullStars
                      ? 'fill-yellow-400 text-yellow-400'
                      : i === fullStars && hasHalfStar
                      ? 'fill-yellow-400/50 text-yellow-400'
                      : 'text-gray-300'
                  }`}
                />
              ))}
            </div>
            <span className="text-2xl font-bold">{avgRating.toFixed(1)}</span>
          </div>
          <div className="text-sm text-muted-foreground">
            총 {reviewCount}개의 리뷰
          </div>
        </div>
      </CardContent>
    </Card>
  );
};
```

#### 3.2.5 Review Components

**파일:** `src/features/reviews/components/ReviewList.tsx`

```typescript
'use client';

import { Card, CardHeader, CardTitle, CardContent } from '@/components/ui/card';
import { ReviewItem } from './ReviewItem';
import type { Review } from '@/features/places/lib/dto';

interface ReviewListProps {
  reviews: Review[];
}

export const ReviewList = ({ reviews }: ReviewListProps) => {
  if (reviews.length === 0) {
    return (
      <Card>
        <CardContent className="pt-6 text-center text-muted-foreground">
          아직 작성된 리뷰가 없습니다
        </CardContent>
      </Card>
    );
  }

  return (
    <Card>
      <CardHeader>
        <CardTitle>리뷰 목록</CardTitle>
      </CardHeader>
      <CardContent className="space-y-4">
        {reviews.map((review) => (
          <ReviewItem key={review.id} review={review} />
        ))}
      </CardContent>
    </Card>
  );
};
```

**파일:** `src/features/reviews/components/ReviewItem.tsx`

```typescript
'use client';

import { Star } from 'lucide-react';
import { format } from 'date-fns';
import { ko } from 'date-fns/locale';
import type { Review } from '@/features/places/lib/dto';

interface ReviewItemProps {
  review: Review;
}

export const ReviewItem = ({ review }: ReviewItemProps) => {
  return (
    <div className="border-b last:border-0 pb-4 last:pb-0">
      <div className="flex items-center justify-between mb-2">
        <div className="flex items-center gap-2">
          <span className="font-medium">{review.author_name}</span>
          <div className="flex">
            {[...Array(5)].map((_, i) => (
              <Star
                key={i}
                className={`h-4 w-4 ${
                  i < review.rating
                    ? 'fill-yellow-400 text-yellow-400'
                    : 'text-gray-300'
                }`}
              />
            ))}
          </div>
        </div>
        <span className="text-xs text-muted-foreground">
          {format(new Date(review.created_at), 'PPP', { locale: ko })}
        </span>
      </div>
      <p className="text-sm text-gray-700">{review.content}</p>
    </div>
  );
};
```

#### 3.2.6 Main Page

**파일:** `src/app/page.tsx`

```typescript
'use client';

import Script from 'next/script';
import { NaverMapContainer } from '@/features/map/components/NaverMapContainer';
import { PlaceDetailModal } from '@/features/places/components/PlaceDetailModal';

export default function HomePage() {
  return (
    <>
      <Script
        strategy="afterInteractive"
        src={`https://oapi.map.naver.com/openapi/v3/maps.js?ncpClientId=${process.env.NEXT_PUBLIC_NAVER_CLIENT_ID}`}
      />
      <div className="relative w-full h-screen">
        <NaverMapContainer />
        <PlaceDetailModal />
      </div>
    </>
  );
}
```

---

## 4. API Specifications

### 4.1 GET /api/places/with-reviews

**목적:** 리뷰가 존재하는 모든 장소 조회 (지도 마커 표시용)

**요청:**
```http
GET /api/places/with-reviews
```

**응답 (성공):**
```json
HTTP/1.1 200 OK
Content-Type: application/json

[
  {
    "id": "uuid-1",
    "naver_place_id": "naver_12345678",
    "name": "맛집",
    "latitude": 37.498095,
    "longitude": 127.027610
  },
  {
    "id": "uuid-2",
    "naver_place_id": "naver_87654321",
    "name": "맛집2",
    "latitude": 37.500000,
    "longitude": 127.030000
  }
]
```

**응답 (실패):**
```json
HTTP/1.1 500 Internal Server Error
Content-Type: application/json

{
  "ok": false,
  "status": 500,
  "error": {
    "code": "PLACES_FETCH_ERROR",
    "message": "Database connection failed"
  }
}
```

### 4.2 GET /api/places/:placeId/reviews

**목적:** 특정 장소의 상세 정보 및 리뷰 목록 조회

**요청:**
```http
GET /api/places/uuid-1/reviews
```

**응답 (성공):**
```json
HTTP/1.1 200 OK
Content-Type: application/json

{
  "place": {
    "id": "uuid-1",
    "naver_place_id": "naver_12345678",
    "name": "맛집",
    "address": "서울시 강남구 역삼동",
    "phone": "02-1234-5678",
    "latitude": 37.498095,
    "longitude": 127.027610
  },
  "reviews": [
    {
      "id": "review-uuid-1",
      "author_name": "홍길동",
      "rating": 5,
      "content": "맛있어요!",
      "created_at": "2025-10-21T10:00:00Z"
    },
    {
      "id": "review-uuid-2",
      "author_name": "김철수",
      "rating": 4,
      "content": "좋아요",
      "created_at": "2025-10-20T15:30:00Z"
    }
  ],
  "avgRating": 4.5,
  "reviewCount": 2
}
```

**응답 (장소 없음):**
```json
HTTP/1.1 404 Not Found
Content-Type: application/json

{
  "ok": false,
  "status": 404,
  "error": {
    "code": "PLACE_NOT_FOUND",
    "message": "Place not found"
  }
}
```

---

## 5. State Management Details

### 5.1 Zustand Store States

```typescript
// 초기 상태
{
  modalState: 'closed',
  modalHistory: [],
  highlightedMarkerId: null,
  mapCenter: { lat: 37.498095, lng: 127.027610 },
  status: 'idle',
  error: null
}

// 마커 클릭 후 상태
{
  modalState: 'place-detail',
  modalHistory: [{ type: 'place-detail', data: { placeId: 'uuid-1' } }],
  highlightedMarkerId: 'uuid-1',
  mapCenter: { lat: 37.498095, lng: 127.027610 },
  status: 'success',
  error: null
}
```

### 5.2 React Query Cache Keys

```typescript
// 리뷰 있는 장소 목록
['places', 'with-reviews'] → PlaceMarker[]

// 특정 장소의 리뷰
['places', placeId, 'reviews'] → PlaceReviewsResponse
```

### 5.3 State Transition Flow

```
[페이지 로드]
  ↓
[usePlacesWithReviews 쿼리 실행]
  ↓
[지도에 마커 렌더링]
  ↓
[사용자가 마커 클릭]
  ↓
[Zustand: setHighlightedMarker(placeId)]
[Zustand: openModal('place-detail', { placeId })]
  ↓
[usePlaceReviews 쿼리 실행]
  ↓
[PlaceDetailModal 렌더링]
  ↓
[사용자가 모달 닫기]
  ↓
[Zustand: closeModal() or goBackModal()]
```

---

## 6. Error Handling

### 6.1 마커 표시 실패 (EC-004)

**발생 조건:** `GET /api/places/with-reviews` API 호출 실패 또는 빈 응답

**처리 방법:**
- 지도는 정상적으로 표시 (강남역 중심)
- 마커 없이 빈 지도 표시
- 검색 기능은 정상 작동 (UC-001 플로우 가능)
- 사용자에게 별도의 에러 메시지 표시하지 않음

**구현:**
```typescript
// NaverMapContainer.tsx
useEffect(() => {
  if (error) {
    setStatus('error');
    setError(error.message);
    // 마커는 렌더링하지 않지만 지도는 유지
  }
}, [error]);
```

### 6.2 장소 정보 조회 실패 (EC-002)

**발생 조건:** 네트워크 오류, Supabase 연결 실패, 또는 `place_id`가 존재하지 않음

**처리 방법:**
- 에러 토스트 메시지 표시: "장소 정보를 불러올 수 없습니다. 잠시 후 다시 시도해주세요."
- 모달을 열지 않고 메인 지도 화면 유지
- 콘솔에 에러 로그 기록

**구현:**
```typescript
// PlaceDetailModal.tsx
{error && (
  <div className="text-red-500 text-center py-8">
    장소 정보를 불러올 수 없습니다. 잠시 후 다시 시도해주세요.
  </div>
)}
```

### 6.3 리뷰가 없는 상태 (EC-001)

**발생 조건:** 마커 표시 조건상 발생하지 않지만, 데이터 동기화 이슈로 발생 가능

**처리 방법:**
- 장소 기본 정보는 표시
- 리뷰 영역에 "아직 작성된 리뷰가 없습니다" 메시지 표시
- "리뷰 작성하기" 버튼은 정상적으로 표시

**구현:**
```typescript
// ReviewList.tsx
if (reviews.length === 0) {
  return (
    <Card>
      <CardContent className="pt-6 text-center text-muted-foreground">
        아직 작성된 리뷰가 없습니다
      </CardContent>
    </Card>
  );
}
```

---

## 7. Performance Optimization

### 7.1 마커 메모이제이션

```typescript
// PlaceMarker.tsx
export const PlaceMarker = memo(({ map, place }: PlaceMarkerProps) => {
  // ...
}, (prevProps, nextProps) => {
  return prevProps.place.id === nextProps.place.id;
});
```

### 7.2 React Query 캐싱 전략

```typescript
// usePlacesWithReviews.ts
staleTime: 5 * 60 * 1000, // 5분 - 지도 마커는 자주 변경되지 않음
gcTime: 10 * 60 * 1000,   // 10분

// usePlaceReviews.ts
staleTime: 30 * 1000,     // 30초 - 리뷰는 비교적 자주 확인
gcTime: 2 * 60 * 1000,    // 2분
```

### 7.3 Zustand Selector 최적화

```typescript
// ❌ 나쁜 예: 전체 상태 구독
const state = useAppStore();

// ✅ 좋은 예: 필요한 부분만 선택
const highlightedMarkerId = useAppStore((state) => state.highlightedMarkerId);
const openModal = useAppStore((state) => state.openModal);
```

---

## 8. Testing Strategy

### 8.1 Backend Unit Tests

**파일:** `src/features/places/backend/__tests__/service.test.ts`

```typescript
describe('PlacesService', () => {
  describe('getPlacesWithReviews', () => {
    it('리뷰가 있는 장소 목록을 반환해야 함', async () => {
      // Given: Supabase 클라이언트 모킹
      const mockClient = createMockSupabaseClient();

      // When: 서비스 호출
      const result = await getPlacesWithReviews(mockClient);

      // Then: 성공 응답
      expect(result.ok).toBe(true);
      expect(result.data).toHaveLength(2);
      expect(result.data[0]).toHaveProperty('id');
      expect(result.data[0]).toHaveProperty('latitude');
    });

    it('데이터베이스 오류 시 실패 응답을 반환해야 함', async () => {
      // Given: 에러를 반환하는 모킹
      const mockClient = createMockSupabaseClient({ error: new Error('DB error') });

      // When: 서비스 호출
      const result = await getPlacesWithReviews(mockClient);

      // Then: 실패 응답
      expect(result.ok).toBe(false);
      expect(result.error.code).toBe(placesErrorCodes.fetchError);
    });
  });

  describe('getPlaceReviewsById', () => {
    it('장소 정보와 리뷰 목록을 반환해야 함', async () => {
      // Given: 유효한 placeId
      const placeId = 'uuid-1';
      const mockClient = createMockSupabaseClient();

      // When: 서비스 호출
      const result = await getPlaceReviewsById(mockClient, placeId);

      // Then: 성공 응답
      expect(result.ok).toBe(true);
      expect(result.data.place).toHaveProperty('name');
      expect(result.data.reviews).toBeInstanceOf(Array);
      expect(result.data.avgRating).toBeGreaterThanOrEqual(0);
      expect(result.data.reviewCount).toBeGreaterThanOrEqual(0);
    });

    it('존재하지 않는 장소 조회 시 404 반환', async () => {
      // Given: 존재하지 않는 placeId
      const placeId = 'non-existent-uuid';
      const mockClient = createMockSupabaseClient({ data: null });

      // When: 서비스 호출
      const result = await getPlaceReviewsById(mockClient, placeId);

      // Then: 404 응답
      expect(result.ok).toBe(false);
      expect(result.status).toBe(404);
      expect(result.error.code).toBe(placesErrorCodes.notFound);
    });

    it('평균 별점이 소수점 첫째자리로 반올림되어야 함', async () => {
      // Given: 평균 별점이 4.67인 경우
      const mockClient = createMockSupabaseClient({
        reviewStats: [{ rating: 5 }, { rating: 4 }, { rating: 5 }]
      });

      // When: 서비스 호출
      const result = await getPlaceReviewsById(mockClient, 'uuid-1');

      // Then: 4.7로 반올림
      expect(result.data.avgRating).toBe(4.7);
    });
  });
});
```

### 8.2 Frontend Component Tests

**파일:** `src/features/places/components/__tests__/PlaceDetailModal.test.tsx`

```typescript
describe('PlaceDetailModal', () => {
  it('모달이 열렸을 때 장소 정보를 표시해야 함', async () => {
    // Given: 모달 상태가 'place-detail'
    const { result } = renderHook(() => useAppStore());
    act(() => {
      result.current.openModal('place-detail', { placeId: 'uuid-1' });
    });

    // When: 컴포넌트 렌더링
    render(<PlaceDetailModal />);

    // Then: 장소 정보 표시
    await waitFor(() => {
      expect(screen.getByText('맛집')).toBeInTheDocument();
      expect(screen.getByText('서울시 강남구 역삼동')).toBeInTheDocument();
    });
  });

  it('로딩 중일 때 스피너를 표시해야 함', () => {
    // Given: 로딩 상태
    const { result } = renderHook(() => useAppStore());
    act(() => {
      result.current.openModal('place-detail', { placeId: 'uuid-1' });
    });

    // When: 컴포넌트 렌더링
    render(<PlaceDetailModal />);

    // Then: 로딩 스피너 표시
    expect(screen.getByRole('status')).toBeInTheDocument();
  });

  it('리뷰 작성하기 버튼 클릭 시 리뷰 작성 모달이 열려야 함', async () => {
    // Given: 장소 상세 모달 열림
    const { result } = renderHook(() => useAppStore());
    act(() => {
      result.current.openModal('place-detail', { placeId: 'uuid-1' });
    });

    render(<PlaceDetailModal />);

    await waitFor(() => {
      expect(screen.getByText('리뷰 작성하기')).toBeInTheDocument();
    });

    // When: 리뷰 작성하기 버튼 클릭
    const reviewButton = screen.getByText('리뷰 작성하기');
    fireEvent.click(reviewButton);

    // Then: 모달 상태가 'review-write'로 변경
    expect(result.current.modalState).toBe('review-write');
  });
});
```

### 8.3 QA Test Sheet

| 테스트 항목 | 시나리오 | 예상 결과 | 실제 결과 | 통과 여부 |
|------------|---------|----------|----------|----------|
| 지도 초기화 | 메인 페이지 진입 | 강남역 중심으로 지도 표시 | | |
| 마커 표시 | 리뷰 있는 장소 마커 렌더링 | 2개 이상의 마커 표시 | | |
| 마커 클릭 | 마커 클릭 시 모달 열기 | 장소 상세 정보 모달 표시 | | |
| 장소 정보 표시 | 모달 내 장소 정보 확인 | 업체명, 주소, 전화번호 표시 | | |
| 평균 별점 표시 | 리뷰 평균 별점 확인 | ★★★★☆ 형태로 표시, 소수점 첫째자리 | | |
| 리뷰 목록 표시 | 리뷰 목록 스크롤 | 최신순 정렬, 작성자명/별점/날짜/내용 표시 | | |
| 리뷰 없는 경우 | 리뷰가 0개인 장소 모달 | "아직 작성된 리뷰가 없습니다" 메시지 | | |
| 모달 닫기 | 모달 외부 클릭 | 메인 지도 화면으로 복귀 | | |
| API 실패 처리 | 네트워크 오류 시뮬레이션 | 에러 메시지 표시, 지도는 유지 | | |
| 리뷰 작성 진입 | "리뷰 작성하기" 버튼 클릭 | UC-003 리뷰 작성 모달 표시 | | |

---

## 9. Deployment Checklist

### 9.1 환경 변수 설정
```bash
# .env.local
NEXT_PUBLIC_NAVER_CLIENT_ID=your_naver_client_id
```

### 9.2 데이터베이스 마이그레이션 확인
- `supabase/migrations/0002_create_places_and_reviews.sql` 적용 여부 확인

### 9.3 필요한 shadcn-ui 컴포넌트 설치
```bash
npx shadcn@latest add dialog
npx shadcn@latest add card
npx shadcn@latest add button
```

### 9.4 네이버 지도 SDK 타입 정의 설치
```bash
npm install --save-dev @types/navermaps
```

### 9.5 필요한 라이브러리 설치 확인
```bash
npm install date-fns zustand @tanstack/react-query
```

---

## 10. Future Improvements

### 10.1 성능 최적화
- 마커 클러스터링 (많은 마커 표시 시)
- Virtual Scrolling (리뷰 목록이 많을 경우)
- React Query Prefetching (마커 호버 시)

### 10.2 UX 개선
- 마커 클릭 시 부드러운 지도 이동 애니메이션
- 모달 열릴 때 fade-in/out 애니메이션
- 스켈레톤 UI (로딩 상태)

### 10.3 기능 확장
- 지도 범위 내 장소만 조회 (성능 개선)
- 마커 필터링 (별점 4점 이상만 보기 등)
- 리뷰 페이지네이션

---

## 11. Module Dependency Diagram

```mermaid
graph LR
    subgraph "Backend Module"
        A[places/backend/route.ts]
        B[places/backend/service.ts]
        C[places/backend/schema.ts]
        D[places/backend/error.ts]

        A --> B
        A --> C
        A --> D
        B --> C
        B --> D
    end

    subgraph "Frontend Module"
        E[places/hooks/usePlacesWithReviews.ts]
        F[places/hooks/usePlaceReviews.ts]
        G[places/lib/dto.ts]
        H[places/components/PlaceDetailModal.tsx]
        I[places/components/PlaceInfo.tsx]
        J[places/components/ReviewStats.tsx]

        E --> G
        F --> G
        G --> C
        H --> F
        H --> I
        H --> J
    end

    subgraph "Map Module"
        K[map/components/NaverMapContainer.tsx]
        L[map/components/PlaceMarker.tsx]
        M[map/hooks/useNaverMap.ts]
        N[map/constants/map.ts]

        K --> L
        K --> M
        K --> N
        L --> E
    end

    subgraph "Shared Module"
        O[stores/useAppStore.ts]
        P[lib/remote/api-client.ts]

        E --> P
        F --> P
        K --> O
        L --> O
        H --> O
    end

    K --> E
    L --> O
```

---

이 구현 계획은 UC-002 기능의 완전한 구현 가이드를 제공합니다. 모든 코드는 AGENTS.md의 코드베이스 구조를 준수하며, 상태 관리는 Zustand와 React Query를 활용한 설계를 따릅니다.
</file>

<file path="002/spec.md">
# UC-002: 지도 마커를 통한 정보 확인 플로우

## Use Case 정보

| 항목 | 내용 |
|------|------|
| **Use Case ID** | UC-002 |
| **Use Case Name** | 지도 마커를 통한 정보 확인 |
| **Primary Actor** | 일반 사용자 |
| **Stakeholders** | - 일반 사용자: 지도에서 직관적으로 음식점 정보를 확인하고자 함<br>- 리뷰 작성자: 작성한 리뷰가 있는 장소가 지도에 표시되기를 원함 |

---

## Precondition

- 사용자가 메인 페이지(지도 화면)에 접속한 상태
- 네이버 지도 SDK가 정상적으로 로드되어 지도가 표시됨
- 하나 이상의 리뷰 데이터가 존재하는 음식점이 Supabase에 저장되어 있음
- 리뷰가 존재하는 장소들의 커스텀 마커가 지도에 표시됨

---

## Trigger

사용자가 지도에 표시된 커스텀 마커를 클릭

---

## Main Scenario

| Step | Actor | Action | System Response |
|:----:|:-----:|:-------|:----------------|
| 1 | User | 메인 페이지 진입 | - 네이버 지도를 강남역 중심으로 초기화<br>- `GET /api/places/with-reviews` API 호출하여 리뷰가 존재하는 장소 목록 조회 |
| 2 | System | - | - 조회된 장소 목록을 지도상에 커스텀 마커로 표시<br>- 각 마커에 `place_id` 정보 연결 |
| 3 | User | 지도에서 원하는 커스텀 마커 클릭 | - 클릭된 마커의 `place_id` 확인<br>- `GET /api/places/:place_id/reviews` API 호출 |
| 4 | System | - | - Supabase `places` 테이블에서 장소 상세 정보 조회<br>- Supabase `reviews` 테이블에서 해당 장소의 리뷰 목록 조회<br>- 평균 별점 및 총 리뷰 개수 계산 (`AVG(rating)`, `COUNT(*)`) |
| 5 | System | - | - 장소 세부 정보 모달 표시<br>- 업체명, 주소, 전화번호 표시<br>- 평균 별점 (★★★★★, 5점 만점) 및 총 리뷰 개수 표시<br>- 리뷰 목록 렌더링 (작성자명, 별점, 게시일자, 내용) |
| 6 | User | 정보 확인 후 모달 외부 클릭 또는 닫기 버튼 클릭 | - 장소 세부 정보 모달 닫기<br>- 메인 페이지(지도 화면)로 복귀 |

---

## Edge Cases

### EC-001: 리뷰가 없는 상태에서 마커 클릭 (이론적 케이스)

**발생 조건:** Precondition에 따르면 리뷰가 존재하는 장소만 마커로 표시되므로 실제로는 발생하지 않음. 하지만 데이터 동기화 이슈로 인해 발생 가능.

**처리:**
- 백엔드 API가 빈 리뷰 목록과 평균 별점 0, 리뷰 개수 0 반환
- 모달에 "아직 작성된 리뷰가 없습니다" 메시지 표시
- "리뷰 작성하기" 버튼은 정상적으로 표시

### EC-002: 장소 정보 조회 API 실패

**발생 조건:** 네트워크 오류, Supabase 연결 실패, 또는 `place_id`가 존재하지 않음

**처리:**
- 에러 토스트 메시지 표시: "장소 정보를 불러올 수 없습니다. 잠시 후 다시 시도해주세요."
- 모달을 열지 않고 메인 지도 화면 유지
- 콘솔에 에러 로그 기록 (디버깅용)

### EC-003: 리뷰 데이터 조회 API 실패

**발생 조건:** Supabase 리뷰 테이블 조회 실패

**처리:**
- 장소 기본 정보는 표시
- 리뷰 영역에 "리뷰를 불러올 수 없습니다" 메시지 표시
- "리뷰 작성하기" 버튼은 정상 작동 (새 리뷰 작성은 가능)

### EC-004: 지도 초기 로드 시 마커 표시 실패

**발생 조건:** `GET /api/places/with-reviews` API 호출 실패 또는 빈 응답

**처리:**
- 지도는 정상적으로 표시 (강남역 중심)
- 마커 없이 빈 지도 표시
- 검색 기능은 정상 작동 (UC-001 플로우 가능)
- 사용자에게 별도의 에러 메시지 표시하지 않음 (리뷰가 없을 수도 있으므로)

### EC-005: 모달 표시 중 다른 마커 클릭

**발생 조건:** 장소 세부 정보 모달이 열린 상태에서 사용자가 지도의 다른 마커 클릭

**처리:**
- 기존 모달을 닫음
- 새로 클릭한 마커의 장소 정보로 모달을 다시 열기
- 또는 기존 모달 내용을 새 장소 정보로 업데이트 (UX 결정 필요)

---

## Business Rules

### BR-001: 마커 표시 조건

- 커스텀 마커는 **리뷰 데이터가 1개 이상 존재하는 장소**에만 표시
- 리뷰가 없는 장소는 검색을 통해서만 접근 가능

### BR-002: 평균 별점 계산

- 평균 별점은 해당 장소의 모든 리뷰 `rating` 값의 산술 평균
- 소수점 첫째 자리까지 표시 (예: 4.5점)
- 리뷰가 없을 경우 0점 또는 "평점 없음" 표시

### BR-003: 리뷰 정렬 순서

- 리뷰 목록은 최신순 정렬 (`created_at DESC`)
- 페이지네이션 미적용 (초기 스펙)

### BR-004: 모달 닫기 동작

- 모달 외부 클릭 시 모달 닫기
- 마커 진입 시 모달을 닫으면 메인 지도 화면으로 복귀
- 검색 결과에서 진입한 경우 UC-001과 동일하게 검색 결과 모달로 복귀

### BR-005: 실시간 데이터 반영

- 마커 클릭 시마다 최신 리뷰 데이터를 API를 통해 조회
- 클라이언트 캐싱 미적용 (초기 스펙)

---

## Sequence Diagram

```plantuml
@startuml
actor User
participant FE as "Frontend"
participant BE as "Backend API"
database DB as "Database"

== 지도 초기화 및 마커 표시 ==

User -> FE: 메인 페이지 접속
activate FE

FE -> FE: 네이버 지도 SDK 초기화 (강남역 중심)
FE -> BE: GET /api/places/with-reviews
activate BE

BE -> DB: SELECT DISTINCT p.* FROM places p\nINNER JOIN reviews r ON p.id = r.place_id
activate DB
DB --> BE: 리뷰 존재 장소 목록\n[{id, naver_place_id, name, latitude, longitude}, ...]
deactivate DB

BE --> FE: 200 OK\n[{id, name, latitude, longitude}, ...]
deactivate BE

FE -> FE: 각 장소에 커스텀 마커 표시\n(latitude, longitude 기반)
FE --> User: 지도 및 마커 표시
deactivate FE

== 마커 클릭 및 장소 정보 조회 ==

User -> FE: 커스텀 마커 클릭
activate FE

FE -> FE: 클릭된 마커의 place_id 확인
FE -> BE: GET /api/places/:place_id/reviews
activate BE

BE -> DB: SELECT * FROM places\nWHERE id = :place_id
activate DB
DB --> BE: 장소 상세 정보\n{id, naver_place_id, name, address, phone, latitude, longitude}
deactivate DB

BE -> DB: SELECT id, author_name, rating, content, created_at\nFROM reviews\nWHERE place_id = :place_id\nORDER BY created_at DESC
activate DB
DB --> BE: 리뷰 목록\n[{id, author_name, rating, content, created_at}, ...]
deactivate DB

BE -> DB: SELECT AVG(rating) as avg_rating, COUNT(*) as review_count\nFROM reviews\nWHERE place_id = :place_id
activate DB
DB --> BE: 평균 별점 및 리뷰 개수\n{avg_rating: 4.5, review_count: 10}
deactivate DB

BE --> FE: 200 OK\n{place: {...}, reviews: [...], avg_rating: 4.5, review_count: 10}
deactivate BE

FE -> FE: 장소 세부 정보 모달 렌더링\n- 업체 정보 (name, address, phone)\n- 평균 별점 및 리뷰 개수\n- 리뷰 목록
FE --> User: 장소 세부 정보 모달 표시
deactivate FE

== 모달 닫기 ==

User -> FE: 모달 외부 클릭 또는 닫기 버튼 클릭
activate FE

FE -> FE: 모달 닫기
FE --> User: 메인 페이지 (지도 화면) 표시
deactivate FE

@enduml
```

---

## 관련 Use Cases

- **UC-001**: 장소 검색 및 정보 확인 플로우 (검색을 통한 진입)
- **UC-003**: 리뷰 작성 플로우 (장소 세부 정보 모달에서 "리뷰 작성하기" 버튼 클릭)

---

## 참고사항

### API 엔드포인트

1. **GET /api/places/with-reviews**
   - 목적: 리뷰가 존재하는 모든 장소 조회 (지도 마커 표시용)
   - 응답: `[{id, naver_place_id, name, latitude, longitude}, ...]`

2. **GET /api/places/:place_id/reviews**
   - 목적: 특정 장소의 상세 정보 및 리뷰 목록 조회
   - 응답: `{place: {...}, reviews: [...], avg_rating, review_count}`

### 데이터베이스 쿼리

```sql
-- 리뷰가 존재하는 장소 조회
SELECT DISTINCT p.*
FROM places p
INNER JOIN reviews r ON p.id = r.place_id;

-- 특정 장소의 리뷰 목록 조회
SELECT id, author_name, rating, content, created_at
FROM reviews
WHERE place_id = :place_id
ORDER BY created_at DESC;

-- 평균 별점 및 리뷰 개수 계산
SELECT
  AVG(rating) as avg_rating,
  COUNT(*) as review_count
FROM reviews
WHERE place_id = :place_id;
```

### UI/UX 고려사항

- 커스텀 마커 디자인은 기본 마커와 시각적으로 구분되어야 함 (색상, 아이콘 등)
- 마커 클릭 시 로딩 인디케이터 표시 (API 응답 대기 중)
- 평균 별점은 시각적으로 별 아이콘 (★★★★☆)으로 표시
- 리뷰가 많을 경우 스크롤 가능한 영역으로 처리
- 모달 애니메이션 (fade-in/out) 적용 권장
</file>

<file path="003/plan.md">
# UC-003: 리뷰 작성 플로우 - 구현 계획서 (Implementation Plan)

## 1. Feature Overview

### 1.1 기능 개요
리뷰 작성 플로우는 사용자가 장소 상세 정보 모달에서 "리뷰 작성하기" 버튼을 클릭하여 리뷰를 작성하고, 성공적으로 제출하면 장소 상세 모달로 복귀하여 업데이트된 리뷰 목록을 확인하는 기능입니다.

### 1.2 핵심 요구사항
- **폼 입력 및 유효성 검사**: react-hook-form + zod를 사용한 실시간 폼 검증
- **비밀번호 보안**: 4자리 숫자 비밀번호를 bcrypt로 해싱하여 저장
- **모달 네비게이션**: 리뷰 작성 완료 후 Zustand의 `goBackModal()`을 통해 장소 상세 모달로 복귀
- **데이터 동기화**: React Query의 `invalidateQueries`를 통한 자동 리뷰 목록 갱신

### 1.3 관련 유스케이스
- **Precondition**: 사용자가 장소 상세 정보 모달을 열어 특정 음식점 정보를 조회한 상태
- **Trigger**: "리뷰 작성하기" 버튼 클릭
- **Success**: 리뷰 저장 성공 → 장소 상세 모달로 복귀 → 리뷰 목록 자동 갱신

---

## 2. Technical Architecture

### 2.1 상태 관리 전략

#### 2.1.1 Form State (react-hook-form + zod)
```typescript
// 리뷰 작성 폼 상태
reviewForm: {
  author_name: string   // 작성자명 (필수, 1-100자)
  rating: number        // 별점 (필수, 1-5)
  content: string       // 리뷰 내용 (필수, 1-500자)
  password: string      // 비밀번호 (필수, 4자리 숫자)
}

// 실시간 유효성 검사 (zod resolver)
- author_name: 필수, 최대 100자
- rating: 1~5 범위
- content: 필수, 최대 500자
- password: 4자리 숫자 정규식
```

#### 2.1.2 Server State (React Query)
```typescript
// Mutation: 리뷰 생성
useCreateReview() → POST /api/reviews
  - onSuccess: invalidateQueries(['reviews', placeId])
  - onError: 폼 에러 메시지 표시

// Query: 리뷰 목록 (자동 재조회)
useReviews(placeId) → GET /api/places/:placeId/reviews
  - 리뷰 작성 성공 시 자동으로 재조회됨
```

#### 2.1.3 UI State (Zustand)
```typescript
// 모달 네비게이션
modalState: 'review-write' → goBackModal() → 'place-detail'
modalHistory: 모달 이력 관리 (복귀 로직용)
```

### 2.2 Backend Architecture (Hono + Supabase)

#### 2.2.1 API Layer
```
POST /api/reviews
  ├─ 요청 검증 (zod schema)
  ├─ 비즈니스 로직 (service.ts)
  │   ├─ place_id 존재 여부 확인
  │   ├─ 비밀번호 bcrypt 해싱
  │   └─ Supabase INSERT
  └─ 응답 반환 (success/failure)
```

#### 2.2.2 Security
- **비밀번호 해싱**: bcrypt (salt rounds: 10)
- **평문 비밀번호**: 절대 저장하지 않음, 클라이언트에서 서버로 전송 후 즉시 해싱
- **유효성 검사**: 클라이언트 + 서버 이중 검증

---

## 3. Module Design

### 3.1 모듈 개요

| 모듈 | 위치 | 역할 | 의존성 |
|------|------|------|--------|
| **Backend API** | `src/features/reviews/backend/route.ts` | 리뷰 작성 API 엔드포인트 | Hono, Zod, Supabase |
| **Service Layer** | `src/features/reviews/backend/service.ts` | 비즈니스 로직 (비밀번호 해싱, DB 저장) | Supabase, bcrypt |
| **Schema Layer** | `src/features/reviews/backend/schema.ts` | 요청/응답 zod 스키마 정의 | Zod |
| **Error Handler** | `src/features/reviews/backend/error.ts` | 에러 코드 정의 | - |
| **Frontend Component** | `src/features/reviews/components/ReviewWriteModal.tsx` | 리뷰 작성 모달 UI | react-hook-form, shadcn-ui |
| **React Query Hook** | `src/features/reviews/hooks/useCreateReview.ts` | 리뷰 생성 mutation | @tanstack/react-query |
| **DTO** | `src/features/reviews/lib/dto.ts` | 백엔드 스키마 재노출 | backend/schema |

### 3.2 공통 모듈 의존성
- `src/backend/http/response.ts`: success/failure/respond 헬퍼
- `src/lib/remote/api-client.ts`: axios 클라이언트
- `src/stores/useAppStore.ts`: Zustand 모달 상태 관리 (goBackModal)

---

## 4. Architecture Diagram

### 4.1 모듈 간 관계도 (Mermaid)

```mermaid
graph TD
    subgraph "Frontend Layer"
        A[ReviewWriteModal.tsx]
        B[useCreateReview.ts]
        C[dto.ts]
        D[useAppStore]
    end

    subgraph "Backend Layer"
        E[route.ts]
        F[service.ts]
        G[schema.ts]
        H[error.ts]
    end

    subgraph "Shared Layer"
        I[response.ts]
        J[api-client.ts]
        K[Supabase Client]
    end

    A -->|react-hook-form| A
    A -->|useCreateReview| B
    A -->|goBackModal| D
    B -->|POST /api/reviews| J
    B -->|invalidateQueries| B
    C -->|re-export| G

    J -->|HTTP Request| E
    E -->|validate params| G
    E -->|call service| F
    E -->|respond| I
    F -->|bcrypt hash| F
    F -->|Supabase INSERT| K
    F -->|return result| I
    F -->|handle errors| H

    style A fill:#e1f5ff
    style B fill:#e1f5ff
    style E fill:#fff4e1
    style F fill:#fff4e1
    style I fill:#e8f5e9
```

### 4.2 데이터 흐름 (Sequence Diagram)

```mermaid
sequenceDiagram
    participant User
    participant Modal as ReviewWriteModal
    participant RHF as react-hook-form
    participant Mutation as useCreateReview
    participant API as POST /api/reviews
    participant Service as service.ts
    participant Supabase
    participant Zustand as useAppStore
    participant RQ as React Query Cache

    User->>Modal: 리뷰 작성 폼 입력
    Modal->>RHF: 실시간 유효성 검사
    RHF-->>Modal: 에러 메시지 표시 (선택적)

    User->>Modal: "리뷰 작성하기" 클릭
    Modal->>RHF: handleSubmit
    RHF->>RHF: 최종 유효성 검사 (zod)

    alt 유효성 검사 실패
        RHF-->>Modal: 에러 메시지 표시
        Modal-->>User: 폼 에러 표시
    else 유효성 검사 성공
        RHF->>Mutation: mutate(reviewData)
        Mutation->>API: POST /api/reviews
        API->>Service: createReview(data)
        Service->>Service: bcrypt.hash(password)
        Service->>Supabase: INSERT INTO reviews
        Supabase-->>Service: 리뷰 생성 완료
        Service-->>API: success(reviewData)
        API-->>Mutation: 201 Created
        Mutation->>RQ: invalidateQueries(['reviews', placeId])
        RQ->>RQ: 리뷰 목록 재조회 트리거
        Mutation-->>Modal: onSuccess
        Modal->>Zustand: goBackModal()
        Zustand-->>Modal: modalState: 'place-detail'
        RQ->>API: GET /api/places/:placeId/reviews
        API-->>RQ: 업데이트된 리뷰 목록
        Modal-->>User: 장소 상세 모달 복귀 (새 리뷰 포함)
    end
```

---

## 5. Implementation Plan

### 5.1 Backend Implementation

#### 5.1.1 Schema Definition (`src/features/reviews/backend/schema.ts`)

**목적**: 요청/응답 데이터 구조를 zod로 정의하여 타입 안전성 확보

```typescript
import { z } from 'zod';

// POST /api/reviews 요청 스키마
export const CreateReviewRequestSchema = z.object({
  place_id: z.string().uuid({ message: 'place_id must be a valid UUID.' }),
  author_name: z.string()
    .min(1, '작성자명을 입력해주세요')
    .max(100, '작성자명은 100자를 초과할 수 없습니다'),
  rating: z.number()
    .int('별점은 정수여야 합니다')
    .min(1, '별점은 1~5 사이여야 합니다')
    .max(5, '별점은 1~5 사이여야 합니다'),
  content: z.string()
    .min(1, '리뷰 내용을 입력해주세요')
    .max(500, '리뷰 내용은 500자를 초과할 수 없습니다'),
  password: z.string()
    .regex(/^\d{4}$/, '비밀번호는 4자리 숫자여야 합니다'),
});

export type CreateReviewRequest = z.infer<typeof CreateReviewRequestSchema>;

// 응답 스키마
export const ReviewResponseSchema = z.object({
  id: z.string().uuid(),
  place_id: z.string().uuid(),
  author_name: z.string(),
  rating: z.number(),
  content: z.string(),
  created_at: z.string(),
});

export type ReviewResponse = z.infer<typeof ReviewResponseSchema>;

// Supabase 테이블 Row 스키마
export const ReviewTableRowSchema = z.object({
  id: z.string().uuid(),
  place_id: z.string().uuid(),
  author_name: z.string(),
  rating: z.number(),
  content: z.string(),
  password_hash: z.string(),
  created_at: z.string(),
  updated_at: z.string(),
});

export type ReviewRow = z.infer<typeof ReviewTableRowSchema>;
```

**검증 규칙**:
- ✅ 작성자명: 필수, 1-100자
- ✅ 별점: 필수, 1-5 정수
- ✅ 리뷰 내용: 필수, 1-500자
- ✅ 비밀번호: 필수, 4자리 숫자 정규식
- ✅ place_id: UUID 형식

#### 5.1.2 Service Layer (`src/features/reviews/backend/service.ts`)

**목적**: 비즈니스 로직 처리 (비밀번호 해싱, DB 저장)

```typescript
import type { SupabaseClient } from '@supabase/supabase-js';
import bcrypt from 'bcryptjs';
import {
  failure,
  success,
  type HandlerResult,
} from '@/backend/http/response';
import {
  ReviewResponseSchema,
  ReviewTableRowSchema,
  type CreateReviewRequest,
  type ReviewResponse,
} from './schema';
import {
  reviewErrorCodes,
  type ReviewServiceError,
} from './error';

const REVIEWS_TABLE = 'reviews';
const PLACES_TABLE = 'places';
const BCRYPT_SALT_ROUNDS = 10;

export const createReview = async (
  client: SupabaseClient,
  data: CreateReviewRequest,
): Promise<HandlerResult<ReviewResponse, ReviewServiceError, unknown>> => {
  // 1. place_id 존재 여부 확인
  const { data: place, error: placeError } = await client
    .from(PLACES_TABLE)
    .select('id')
    .eq('id', data.place_id)
    .maybeSingle();

  if (placeError) {
    return failure(500, reviewErrorCodes.fetchError, placeError.message);
  }

  if (!place) {
    return failure(404, reviewErrorCodes.placeNotFound, '존재하지 않는 장소입니다');
  }

  // 2. 비밀번호 해싱
  const passwordHash = await bcrypt.hash(data.password, BCRYPT_SALT_ROUNDS);

  // 3. 리뷰 저장
  const { data: reviewRow, error: insertError } = await client
    .from(REVIEWS_TABLE)
    .insert({
      place_id: data.place_id,
      author_name: data.author_name,
      rating: data.rating,
      content: data.content,
      password_hash: passwordHash,
    })
    .select('id, place_id, author_name, rating, content, created_at')
    .single();

  if (insertError) {
    return failure(500, reviewErrorCodes.createError, '리뷰 작성에 실패했습니다', insertError.message);
  }

  // 4. 응답 데이터 검증
  const parsed = ReviewResponseSchema.safeParse(reviewRow);

  if (!parsed.success) {
    return failure(
      500,
      reviewErrorCodes.validationError,
      '리뷰 데이터 검증에 실패했습니다',
      parsed.error.format(),
    );
  }

  return success(parsed.data, 201);
};
```

**핵심 로직**:
- ✅ place_id 존재 확인 (404 에러 처리)
- ✅ bcrypt.hash(password, 10) 사용
- ✅ Supabase INSERT 후 생성된 데이터 반환
- ✅ 응답 데이터 zod 검증

#### 5.1.3 Error Codes (`src/features/reviews/backend/error.ts`)

```typescript
export const reviewErrorCodes = {
  placeNotFound: 'PLACE_NOT_FOUND',
  createError: 'REVIEW_CREATE_ERROR',
  fetchError: 'REVIEW_FETCH_ERROR',
  validationError: 'REVIEW_VALIDATION_ERROR',
} as const;

type ReviewErrorValue = (typeof reviewErrorCodes)[keyof typeof reviewErrorCodes];

export type ReviewServiceError = ReviewErrorValue;
```

#### 5.1.4 Route Handler (`src/features/reviews/backend/route.ts`)

**목적**: Hono 라우터 정의 및 요청/응답 처리

```typescript
import type { Hono } from 'hono';
import {
  failure,
  respond,
  type ErrorResult,
} from '@/backend/http/response';
import {
  getLogger,
  getSupabase,
  type AppEnv,
} from '@/backend/hono/context';
import { CreateReviewRequestSchema } from './schema';
import { createReview } from './service';
import {
  reviewErrorCodes,
  type ReviewServiceError,
} from './error';

export const registerReviewRoutes = (app: Hono<AppEnv>) => {
  app.post('/reviews', async (c) => {
    const body = await c.req.json();
    const parsedBody = CreateReviewRequestSchema.safeParse(body);

    if (!parsedBody.success) {
      return respond(
        c,
        failure(
          400,
          'INVALID_REVIEW_REQUEST',
          '리뷰 요청 데이터가 올바르지 않습니다',
          parsedBody.error.format(),
        ),
      );
    }

    const supabase = getSupabase(c);
    const logger = getLogger(c);

    const result = await createReview(supabase, parsedBody.data);

    if (!result.ok) {
      const errorResult = result as ErrorResult<ReviewServiceError, unknown>;

      if (errorResult.error.code === reviewErrorCodes.createError) {
        logger.error('Failed to create review', errorResult.error.message);
      }

      return respond(c, result);
    }

    return respond(c, result);
  });
};
```

**처리 흐름**:
1. ✅ 요청 body 파싱
2. ✅ zod 스키마 검증 (400 에러)
3. ✅ service.createReview 호출
4. ✅ 에러 로깅 (필요 시)
5. ✅ success/failure 응답 반환

#### 5.1.5 Hono App 라우터 등록

**파일**: `src/backend/hono/app.ts`에 라우터 등록

```typescript
import { registerReviewRoutes } from '@/features/reviews/backend/route';

export const createHonoApp = () => {
  const app = new Hono<AppEnv>();

  // ... 기존 미들웨어 ...

  registerReviewRoutes(app);  // ← 추가

  return app;
};
```

---

### 5.2 Frontend Implementation

#### 5.2.1 DTO (`src/features/reviews/lib/dto.ts`)

**목적**: 백엔드 스키마를 프론트엔드에서 재사용

```typescript
export {
  CreateReviewRequestSchema,
  ReviewResponseSchema,
  type CreateReviewRequest,
  type ReviewResponse,
} from '@/features/reviews/backend/schema';
```

#### 5.2.2 React Query Hook (`src/features/reviews/hooks/useCreateReview.ts`)

**목적**: 리뷰 생성 mutation 훅

```typescript
'use client';

import { useMutation, useQueryClient } from '@tanstack/react-query';
import { apiClient, extractApiErrorMessage } from '@/lib/remote/api-client';
import {
  CreateReviewRequestSchema,
  type CreateReviewRequest,
  type ReviewResponse,
} from '@/features/reviews/lib/dto';

const postReview = async (data: CreateReviewRequest): Promise<ReviewResponse> => {
  try {
    const { data: responseData } = await apiClient.post('/api/reviews', data);
    return responseData;
  } catch (error) {
    const message = extractApiErrorMessage(error, '리뷰 작성에 실패했습니다');
    throw new Error(message);
  }
};

export const useCreateReview = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: postReview,
    onSuccess: (data, variables) => {
      // 리뷰 목록 무효화 → 자동 재조회
      queryClient.invalidateQueries({
        queryKey: ['reviews', variables.place_id],
      });
    },
  });
};
```

**핵심 로직**:
- ✅ POST /api/reviews 호출
- ✅ onSuccess: invalidateQueries로 리뷰 목록 갱신
- ✅ extractApiErrorMessage로 에러 처리

#### 5.2.3 Review Write Modal (`src/features/reviews/components/ReviewWriteModal.tsx`)

**목적**: 리뷰 작성 폼 UI 및 상태 관리

```typescript
'use client';

import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';
import { useCreateReview } from '@/features/reviews/hooks/useCreateReview';
import { useAppStore } from '@/stores/useAppStore';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Textarea } from '@/components/ui/textarea';
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
} from '@/components/ui/dialog';
import { Label } from '@/components/ui/label';
import { Alert, AlertDescription } from '@/components/ui/alert';

// 클라이언트 전용 폼 스키마 (password 평문)
const reviewFormSchema = z.object({
  author_name: z.string()
    .min(1, '작성자명을 입력해주세요')
    .max(100, '작성자명은 100자를 초과할 수 없습니다'),
  rating: z.number()
    .int()
    .min(1, '별점을 선택해주세요')
    .max(5, '별점은 1~5 사이여야 합니다'),
  content: z.string()
    .min(1, '리뷰 내용을 입력해주세요')
    .max(500, '리뷰 내용은 500자를 초과할 수 없습니다'),
  password: z.string()
    .regex(/^\d{4}$/, '비밀번호는 4자리 숫자여야 합니다'),
});

type ReviewFormData = z.infer<typeof reviewFormSchema>;

interface ReviewWriteModalProps {
  placeId: string;
  placeName: string;
  placeAddress: string;
}

export const ReviewWriteModal = ({
  placeId,
  placeName,
  placeAddress,
}: ReviewWriteModalProps) => {
  const { modalState, goBackModal } = useAppStore();
  const createReview = useCreateReview();

  const form = useForm<ReviewFormData>({
    resolver: zodResolver(reviewFormSchema),
    defaultValues: {
      author_name: '',
      rating: 0,
      content: '',
      password: '',
    },
  });

  const onSubmit = async (data: ReviewFormData) => {
    try {
      await createReview.mutateAsync({
        place_id: placeId,
        ...data,
      });
      goBackModal(); // 성공 시 장소 상세 모달로 복귀
    } catch (error) {
      form.setError('root', {
        message: error instanceof Error ? error.message : '리뷰 작성에 실패했습니다',
      });
    }
  };

  const isOpen = modalState === 'review-write';

  return (
    <Dialog open={isOpen} onOpenChange={() => goBackModal()}>
      <DialogContent className="max-w-md">
        <DialogHeader>
          <DialogTitle>리뷰 작성하기</DialogTitle>
        </DialogHeader>

        {/* 장소 정보 표시 */}
        <div className="mb-4 p-3 bg-gray-50 rounded">
          <p className="font-semibold">{placeName}</p>
          <p className="text-sm text-gray-600">{placeAddress}</p>
        </div>

        <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4">
          {/* 작성자명 */}
          <div>
            <Label htmlFor="author_name">작성자명 *</Label>
            <Input
              id="author_name"
              {...form.register('author_name')}
              placeholder="이름을 입력하세요"
            />
            {form.formState.errors.author_name && (
              <p className="text-sm text-red-600 mt-1">
                {form.formState.errors.author_name.message}
              </p>
            )}
          </div>

          {/* 별점 */}
          <div>
            <Label htmlFor="rating">별점 *</Label>
            <select
              id="rating"
              {...form.register('rating', { valueAsNumber: true })}
              className="w-full border rounded px-3 py-2"
            >
              <option value={0}>별점 선택</option>
              <option value={1}>⭐ 1점</option>
              <option value={2}>⭐⭐ 2점</option>
              <option value={3}>⭐⭐⭐ 3점</option>
              <option value={4}>⭐⭐⭐⭐ 4점</option>
              <option value={5}>⭐⭐⭐⭐⭐ 5점</option>
            </select>
            {form.formState.errors.rating && (
              <p className="text-sm text-red-600 mt-1">
                {form.formState.errors.rating.message}
              </p>
            )}
          </div>

          {/* 리뷰 내용 */}
          <div>
            <Label htmlFor="content">리뷰 내용 *</Label>
            <Textarea
              id="content"
              {...form.register('content')}
              placeholder="리뷰를 작성해주세요 (최대 500자)"
              rows={5}
            />
            <div className="flex justify-between items-center mt-1">
              {form.formState.errors.content && (
                <p className="text-sm text-red-600">
                  {form.formState.errors.content.message}
                </p>
              )}
              <p className="text-sm text-gray-500 ml-auto">
                {form.watch('content')?.length || 0} / 500자
              </p>
            </div>
          </div>

          {/* 비밀번호 */}
          <div>
            <Label htmlFor="password">비밀번호 (4자리 숫자) *</Label>
            <Input
              id="password"
              type="password"
              {...form.register('password')}
              placeholder="4자리 숫자"
              maxLength={4}
            />
            {form.formState.errors.password && (
              <p className="text-sm text-red-600 mt-1">
                {form.formState.errors.password.message}
              </p>
            )}
          </div>

          {/* 전역 에러 */}
          {form.formState.errors.root && (
            <Alert variant="destructive">
              <AlertDescription>{form.formState.errors.root.message}</AlertDescription>
            </Alert>
          )}

          {/* 제출 버튼 */}
          <div className="flex justify-end gap-2">
            <Button
              type="button"
              variant="outline"
              onClick={() => goBackModal()}
              disabled={createReview.isPending}
            >
              취소
            </Button>
            <Button
              type="submit"
              disabled={createReview.isPending}
            >
              {createReview.isPending ? '작성 중...' : '리뷰 작성하기'}
            </Button>
          </div>
        </form>
      </DialogContent>
    </Dialog>
  );
};
```

**핵심 기능**:
- ✅ react-hook-form + zodResolver 사용
- ✅ 실시간 유효성 검사 및 에러 메시지 표시
- ✅ 글자 수 카운터 (content)
- ✅ 제출 중 버튼 비활성화
- ✅ 성공 시 goBackModal() 호출
- ✅ 에러 시 root 에러 표시

---

### 5.3 Validation Rules

#### 5.3.1 클라이언트 측 검증 (react-hook-form + zod)

| 필드 | 규칙 | 에러 메시지 |
|------|------|-------------|
| `author_name` | 필수, 1-100자 | "작성자명을 입력해주세요" / "작성자명은 100자를 초과할 수 없습니다" |
| `rating` | 필수, 1-5 정수 | "별점을 선택해주세요" / "별점은 1~5 사이여야 합니다" |
| `content` | 필수, 1-500자 | "리뷰 내용을 입력해주세요" / "리뷰 내용은 500자를 초과할 수 없습니다" |
| `password` | 필수, 4자리 숫자 | "비밀번호는 4자리 숫자여야 합니다" |

#### 5.3.2 서버 측 검증 (zod + Supabase)

| 검증 항목 | 처리 | 응답 |
|---------|------|------|
| place_id 존재 여부 | Supabase SELECT 쿼리 | 404: "존재하지 않는 장소입니다" |
| 필드 형식 검증 | zod safeParse | 400: "리뷰 요청 데이터가 올바르지 않습니다" |
| rating 범위 | zod min/max | 400: "별점은 1~5 사이여야 합니다" |
| content 길이 | zod max | 400: "리뷰 내용은 500자를 초과할 수 없습니다" |

---

## 6. API Specifications

### 6.1 POST /api/reviews

#### Request
```http
POST /api/reviews
Content-Type: application/json

{
  "place_id": "uuid-1",
  "author_name": "홍길동",
  "rating": 5,
  "content": "맛있어요!",
  "password": "1234"
}
```

#### Response (Success)
```http
HTTP/1.1 201 Created
Content-Type: application/json

{
  "id": "review-uuid",
  "place_id": "uuid-1",
  "author_name": "홍길동",
  "rating": 5,
  "content": "맛있어요!",
  "created_at": "2025-10-22T10:00:00Z"
}
```

#### Response (Error - 400 Bad Request)
```http
HTTP/1.1 400 Bad Request
Content-Type: application/json

{
  "error": {
    "code": "INVALID_REVIEW_REQUEST",
    "message": "리뷰 요청 데이터가 올바르지 않습니다",
    "details": {
      "rating": {
        "_errors": ["별점은 1~5 사이여야 합니다"]
      }
    }
  }
}
```

#### Response (Error - 404 Not Found)
```http
HTTP/1.1 404 Not Found
Content-Type: application/json

{
  "error": {
    "code": "PLACE_NOT_FOUND",
    "message": "존재하지 않는 장소입니다"
  }
}
```

#### Response (Error - 500 Internal Server Error)
```http
HTTP/1.1 500 Internal Server Error
Content-Type: application/json

{
  "error": {
    "code": "REVIEW_CREATE_ERROR",
    "message": "리뷰 작성에 실패했습니다",
    "details": "Database error details"
  }
}
```

---

## 7. Security Considerations

### 7.1 비밀번호 보안

#### 7.1.1 해싱 알고리즘
- **알고리즘**: bcrypt
- **Salt Rounds**: 10
- **라이브러리**: `bcryptjs` (Node.js 호환)

#### 7.1.2 처리 흐름
```
[클라이언트]
  password: "1234" (평문)
    ↓
[POST /api/reviews]
    ↓
[service.ts]
  bcrypt.hash("1234", 10)
    ↓
  password_hash: "$2b$10$abcd..." (해시)
    ↓
[Supabase INSERT]
  reviews.password_hash 저장
```

#### 7.1.3 주의사항
- ❌ 평문 비밀번호를 절대 저장하지 않음
- ✅ 클라이언트에서 서버로 전송 후 즉시 해싱
- ✅ 해시된 비밀번호만 DB에 저장
- ✅ 향후 리뷰 수정/삭제 시 bcrypt.compare() 사용

### 7.2 입력 검증
- **클라이언트**: react-hook-form + zod resolver
- **서버**: zod safeParse + Supabase 제약 조건
- **이중 검증**: 클라이언트와 서버 모두에서 검증

---

## 8. Error Handling

### 8.1 에러 처리 전략

#### 8.1.1 클라이언트 에러
```typescript
// react-hook-form 에러
form.setError('author_name', { message: '작성자명을 입력해주세요' })

// 전역 에러 (API 실패)
form.setError('root', { message: '리뷰 작성에 실패했습니다' })
```

#### 8.1.2 서버 에러

| 에러 코드 | HTTP 상태 | 설명 | 처리 |
|----------|----------|------|------|
| `INVALID_REVIEW_REQUEST` | 400 | 요청 데이터 검증 실패 | zod 에러 details 반환 |
| `PLACE_NOT_FOUND` | 404 | place_id가 존재하지 않음 | "존재하지 않는 장소입니다" |
| `REVIEW_CREATE_ERROR` | 500 | Supabase INSERT 실패 | 서버 에러 로깅 |
| `REVIEW_VALIDATION_ERROR` | 500 | 응답 데이터 검증 실패 | zod 에러 details 반환 |

#### 8.1.3 에러 처리 흐름
```
[클라이언트] → [API] → [Service]
                 ↓ 에러 발생
            [failure()] 생성
                 ↓
            [respond(c, failure)]
                 ↓
         [클라이언트 에러 핸들러]
                 ↓
         [form.setError('root')]
                 ↓
         [Alert UI 표시]
```

---

## 9. State Management Details

### 9.1 React Hook Form
```typescript
// 폼 상태
const form = useForm<ReviewFormData>({
  resolver: zodResolver(reviewFormSchema),
  defaultValues: {
    author_name: '',
    rating: 0,
    content: '',
    password: '',
  },
});

// 실시간 검증
form.formState.errors.author_name?.message

// 제출 처리
form.handleSubmit(onSubmit)

// 에러 설정
form.setError('root', { message: '에러 메시지' })
```

### 9.2 React Query
```typescript
// Mutation
const createReview = useCreateReview();

// 제출
createReview.mutateAsync(data);

// 상태
createReview.isPending  // 로딩 상태
createReview.isError    // 에러 발생 여부

// onSuccess: invalidateQueries
queryClient.invalidateQueries({ queryKey: ['reviews', placeId] });
```

### 9.3 Zustand Modal Navigation
```typescript
// 모달 상태
const { modalState, goBackModal } = useAppStore();

// 모달 복귀 (리뷰 작성 완료 시)
goBackModal(); // 'review-write' → 'place-detail'

// 모달 히스토리
modalHistory: [
  { type: 'place-detail', data: { placeId: 'uuid-1' } },
  { type: 'review-write', data: { placeId: 'uuid-1' } },
]
```

---

## 10. Testing Strategy

### 10.1 Backend Unit Tests

#### 10.1.1 Service Layer 테스트 (`service.test.ts`)

```typescript
describe('createReview', () => {
  it('should create review successfully', async () => {
    const result = await createReview(mockSupabase, {
      place_id: 'uuid-1',
      author_name: '홍길동',
      rating: 5,
      content: '맛있어요',
      password: '1234',
    });

    expect(result.ok).toBe(true);
    expect(result.data.author_name).toBe('홍길동');
  });

  it('should return 404 if place not found', async () => {
    const result = await createReview(mockSupabase, {
      place_id: 'invalid-uuid',
      author_name: '홍길동',
      rating: 5,
      content: '맛있어요',
      password: '1234',
    });

    expect(result.ok).toBe(false);
    expect(result.error.code).toBe('PLACE_NOT_FOUND');
  });

  it('should hash password using bcrypt', async () => {
    const result = await createReview(mockSupabase, {
      place_id: 'uuid-1',
      author_name: '홍길동',
      rating: 5,
      content: '맛있어요',
      password: '1234',
    });

    // DB에 저장된 password_hash 확인
    const savedReview = await mockSupabase
      .from('reviews')
      .select('password_hash')
      .eq('id', result.data.id)
      .single();

    const isMatch = await bcrypt.compare('1234', savedReview.data.password_hash);
    expect(isMatch).toBe(true);
  });

  it('should reject invalid rating', async () => {
    const result = await createReview(mockSupabase, {
      place_id: 'uuid-1',
      author_name: '홍길동',
      rating: 6, // 유효하지 않은 별점
      content: '맛있어요',
      password: '1234',
    });

    expect(result.ok).toBe(false);
    expect(result.error.code).toBe('REVIEW_VALIDATION_ERROR');
  });
});
```

### 10.2 Frontend Component Tests

#### 10.2.1 ReviewWriteModal QA Sheet

| 테스트 케이스 | 입력 | 기대 결과 |
|-------------|-----|----------|
| **필수 항목 검증** | 작성자명 미입력 | "작성자명을 입력해주세요" 에러 메시지 표시 |
| **별점 선택** | 별점 0 (미선택) | "별점을 선택해주세요" 에러 메시지 표시 |
| **리뷰 내용 길이** | 501자 입력 | "리뷰 내용은 500자를 초과할 수 없습니다" 에러 메시지 표시 |
| **비밀번호 형식** | "abc1" 입력 | "비밀번호는 4자리 숫자여야 합니다" 에러 메시지 표시 |
| **글자 수 카운터** | 리뷰 내용 입력 | 실시간으로 "X / 500자" 표시 |
| **정상 제출** | 모든 항목 올바르게 입력 | 리뷰 작성 성공 → 장소 상세 모달로 복귀 |
| **중복 제출 방지** | 제출 버튼 연속 클릭 | 버튼 비활성화 + "작성 중..." 표시 |
| **모달 닫기** | ESC 키 또는 취소 버튼 | goBackModal() 호출 → 장소 상세 모달로 복귀 |
| **네트워크 에러** | API 실패 | Alert에 에러 메시지 표시 + 폼 데이터 유지 |

#### 10.2.2 React Query Hook 테스트

```typescript
describe('useCreateReview', () => {
  it('should invalidate reviews query on success', async () => {
    const { result } = renderHook(() => useCreateReview(), {
      wrapper: createQueryClientWrapper(),
    });

    await act(async () => {
      await result.current.mutateAsync({
        place_id: 'uuid-1',
        author_name: '홍길동',
        rating: 5,
        content: '맛있어요',
        password: '1234',
      });
    });

    // invalidateQueries 호출 확인
    expect(queryClient.getQueryState(['reviews', 'uuid-1'])?.isInvalidated).toBe(true);
  });
});
```

---

## 11. Dependencies

### 11.1 Backend Dependencies

```json
{
  "dependencies": {
    "hono": "^4.x",
    "zod": "^3.x",
    "@supabase/supabase-js": "^2.x",
    "bcryptjs": "^2.x"
  },
  "devDependencies": {
    "@types/bcryptjs": "^2.x"
  }
}
```

### 11.2 Frontend Dependencies

```json
{
  "dependencies": {
    "react-hook-form": "^7.x",
    "@hookform/resolvers": "^3.x",
    "zod": "^3.x",
    "@tanstack/react-query": "^5.x",
    "zustand": "^4.x",
    "axios": "^1.x"
  }
}
```

### 11.3 Shadcn-ui Components

설치 필요 컴포넌트:
```bash
npx shadcn@latest add dialog
npx shadcn@latest add button
npx shadcn@latest add input
npx shadcn@latest add textarea
npx shadcn@latest add label
npx shadcn@latest add alert
```

---

## 12. Deployment Checklist

### 12.1 Backend 배포 전 체크리스트
- ✅ `registerReviewRoutes(app)` 를 `src/backend/hono/app.ts`에 등록
- ✅ Supabase migration 파일 적용 (reviews 테이블 생성)
- ✅ bcryptjs 패키지 설치 확인
- ✅ 환경 변수 설정 (SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY)

### 12.2 Frontend 배포 전 체크리스트
- ✅ shadcn-ui 컴포넌트 설치 (dialog, button, input, textarea, label, alert)
- ✅ Zustand store에 `goBackModal()` 메서드 구현 확인
- ✅ API baseURL 설정 (NEXT_PUBLIC_API_BASE_URL)
- ✅ 리뷰 작성 모달 컴포넌트를 장소 상세 페이지에 통합

### 12.3 통합 테스트
- ✅ 리뷰 작성 → 제출 → 장소 상세 모달 복귀 → 리뷰 목록 갱신 확인
- ✅ 비밀번호 해싱 확인 (Supabase DB에서 password_hash 확인)
- ✅ 에러 핸들링 확인 (필수 항목 누락, 네트워크 오류 등)

---

## 13. Migration SQL

### 13.1 reviews 테이블 마이그레이션

**파일**: `supabase/migrations/0003_create_reviews_table.sql`

```sql
-- Enable uuid extension if not already enabled
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- Create reviews table
CREATE TABLE IF NOT EXISTS reviews (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  place_id UUID NOT NULL REFERENCES places(id) ON DELETE CASCADE,
  author_name VARCHAR(100) NOT NULL,
  rating INTEGER NOT NULL CHECK (rating >= 1 AND rating <= 5),
  content TEXT NOT NULL CHECK (LENGTH(content) <= 500),
  password_hash VARCHAR(255) NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Create indexes for performance
CREATE INDEX IF NOT EXISTS idx_reviews_place_id ON reviews(place_id);
CREATE INDEX IF NOT EXISTS idx_reviews_created_at ON reviews(created_at DESC);

-- Create trigger for updated_at
CREATE OR REPLACE FUNCTION update_reviews_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_reviews_updated_at
BEFORE UPDATE ON reviews
FOR EACH ROW
EXECUTE FUNCTION update_reviews_updated_at();

-- Disable RLS (as per project guidelines)
ALTER TABLE reviews DISABLE ROW LEVEL SECURITY;

COMMENT ON TABLE reviews IS '음식점 리뷰 데이터';
COMMENT ON COLUMN reviews.password_hash IS 'bcrypt 해싱된 비밀번호 (수정/삭제 시 본인 확인용)';
```

---

## 14. Summary

### 14.1 구현 범위

| 레이어 | 구현 모듈 | 주요 기능 |
|-------|----------|---------|
| **Backend** | route.ts, service.ts, schema.ts, error.ts | POST /api/reviews, 비밀번호 해싱, 유효성 검사 |
| **Frontend** | ReviewWriteModal.tsx, useCreateReview.ts, dto.ts | 리뷰 작성 폼, React Query mutation |
| **State** | react-hook-form, React Query, Zustand | 폼 검증, 데이터 동기화, 모달 네비게이션 |
| **Database** | Supabase migration | reviews 테이블 생성, 인덱스, 트리거 |

### 14.2 핵심 플로우

```
[사용자] → [리뷰 작성 폼] → [react-hook-form 검증]
  → [POST /api/reviews] → [bcrypt 해싱] → [Supabase INSERT]
  → [성공 응답] → [invalidateQueries] → [goBackModal()]
  → [장소 상세 모달 복귀] → [리뷰 목록 자동 갱신]
```

### 14.3 품질 보증

- ✅ **타입 안전성**: TypeScript + zod 스키마
- ✅ **보안**: bcrypt 비밀번호 해싱
- ✅ **검증**: 클라이언트 + 서버 이중 검증
- ✅ **UX**: 실시간 에러 메시지, 글자 수 카운터, 로딩 상태
- ✅ **데이터 동기화**: React Query invalidation
- ✅ **에러 처리**: 명확한 에러 코드 및 메시지

---

## 15. Next Steps (향후 확장 고려사항)

### 15.1 리뷰 수정/삭제 기능
- 비밀번호 확인 (`bcrypt.compare`)
- PATCH /api/reviews/:id
- DELETE /api/reviews/:id

### 15.2 리뷰 이미지 업로드
- Supabase Storage 연동
- review_images 테이블 추가
- 파일 업로드 UI

### 15.3 리뷰 좋아요 기능
- review_likes 테이블 추가
- 좋아요 수 표시

### 15.4 리뷰 신고 기능
- review_reports 테이블 추가
- 관리자 심사 로직

---

**문서 작성일**: 2025-10-22
**작성자**: 6-plan-writer Agent
**버전**: 1.0
</file>

<file path="003/spec.md">
# 003. 리뷰 작성 플로우 - 상세 유스케이스

## Primary Actor
일반 사용자 (음식점을 방문하고 경험을 공유하려는 사용자)

## Precondition
- 사용자가 장소 세부 정보 모달을 열어 특정 음식점 정보를 조회한 상태
- 해당 장소가 places 테이블에 존재하는 상태

## Trigger
사용자가 [장소 세부 정보 모달]에서 "리뷰 작성하기" 버튼을 클릭

## Main Scenario

### 1. 리뷰 작성 진입
1. 사용자가 장소 세부 정보 모달에서 "리뷰 작성하기" 버튼을 클릭한다.
2. 시스템이 리뷰 작성 모달을 열고, 상단에 현재 장소의 기본 정보(업체명, 주소)를 표시한다.

### 2. 리뷰 정보 입력
사용자가 다음 항목을 입력한다:
- **작성자명**: 텍스트 입력 (필수, 최대 100자)
- **별점**: 1~5점 중 선택 (필수)
- **리뷰 내용**: 텍스트 영역 (필수, 최대 500자)
- **비밀번호**: 4자리 숫자 입력 (필수)

### 3. 리뷰 제출
1. 사용자가 모든 필수 항목을 입력하고 "리뷰 작성하기" 버튼을 클릭한다.
2. 시스템이 클라이언트 측 유효성 검사를 실행한다:
   - 작성자명: 필수 입력, 100자 이하
   - 별점: 1~5 범위 내 선택
   - 리뷰 내용: 필수 입력, 500자 이하
   - 비밀번호: 정확히 4자리 숫자
3. 유효성 검사 통과 시, 시스템이 백엔드 API `POST /api/reviews`를 호출한다.
4. 백엔드가 추가 유효성 검사를 실행한다:
   - place_id 존재 여부 확인
   - 모든 필드 형식 및 범위 재검증
5. 백엔드가 비밀번호를 bcrypt로 해싱한다.
6. 백엔드가 reviews 테이블에 리뷰 데이터를 저장한다.
7. 백엔드가 생성된 리뷰 데이터를 응답으로 반환한다.

### 4. 리뷰 작성 완료
1. 시스템이 리뷰 작성 모달을 닫는다.
2. 시스템이 장소 세부 정보 모달로 복귀한다.
3. 시스템이 `GET /api/places/:place_id/reviews`를 재호출하여 업데이트된 리뷰 목록을 조회한다.
4. 시스템이 새로 계산된 평균 별점과 총 리뷰 개수를 표시한다.
5. 사용자가 방금 작성한 리뷰를 포함한 전체 리뷰 목록을 확인한다.

## Edge Cases

### E1. 필수 항목 누락
**상황**: 사용자가 필수 항목(작성자명, 별점, 리뷰 내용, 비밀번호) 중 하나라도 입력하지 않은 상태에서 "리뷰 작성하기" 버튼을 클릭
- **처리**: 클라이언트 측 유효성 검사가 실패하고, 해당 필드에 에러 메시지를 표시한다 (예: "작성자명을 입력해주세요").
- **결과**: 리뷰 작성 모달이 유지되며, 사용자가 누락된 항목을 입력할 수 있다.

### E2. 리뷰 내용 글자 수 초과
**상황**: 사용자가 리뷰 내용을 500자를 초과하여 입력
- **처리**:
  - 실시간으로 글자 수를 표시하고 500자 초과 시 경고 메시지를 표시한다.
  - 제출 시 유효성 검사가 실패하고 "리뷰 내용은 500자를 초과할 수 없습니다 (현재: XXX자)" 메시지를 표시한다.
- **결과**: 사용자가 글자 수를 줄여 500자 이하로 수정할 수 있다.

### E3. 비밀번호 형식 오류
**상황**: 사용자가 4자리 숫자가 아닌 값을 비밀번호로 입력 (예: "abc1", "12345", "12 3")
- **처리**: 클라이언트 측 유효성 검사가 실패하고 "비밀번호는 4자리 숫자여야 합니다" 메시지를 표시한다.
- **결과**: 사용자가 올바른 형식으로 재입력할 수 있다.

### E4. 네트워크 오류
**상황**: 리뷰 제출 중 네트워크 오류 또는 서버 응답 실패
- **처리**: 에러 메시지를 표시하고 (예: "리뷰 작성에 실패했습니다. 다시 시도해주세요"), 입력된 데이터를 유지한다.
- **결과**: 사용자가 동일한 데이터로 재시도할 수 있다.

### E5. 장소가 존재하지 않음
**상황**: 백엔드에서 place_id로 장소 조회 시 해당 장소가 존재하지 않음
- **처리**: 백엔드가 400 에러와 "존재하지 않는 장소입니다" 메시지를 반환한다.
- **결과**: 프론트엔드가 에러 메시지를 표시하고 모달을 닫는다.

### E6. 모달 외부 클릭 또는 ESC 키
**상황**: 사용자가 리뷰 작성 중 모달 외부를 클릭하거나 ESC 키를 누름
- **처리**:
  - 입력된 데이터가 있는 경우: "작성 중인 내용이 있습니다. 정말 닫으시겠습니까?" 확인 대화상자를 표시한다.
  - 확인 시: 리뷰 작성 모달을 닫고 장소 세부 정보 모달로 복귀한다.
  - 취소 시: 리뷰 작성 모달을 유지한다.
- **결과**: 사용자의 의도를 재확인하여 실수로 인한 데이터 손실을 방지한다.

## Business Rules

### BR1. 데이터 유효성 규칙
- **작성자명**: 필수, 1~100자 이내
- **별점**: 필수, 1~5 정수 중 하나
- **리뷰 내용**: 필수, 1~500자 이내
- **비밀번호**: 필수, 정확히 4자리 숫자 (0000~9999)

### BR2. 비밀번호 보안
- 비밀번호는 평문으로 저장하지 않으며, bcrypt 알고리즘(salt rounds: 10)으로 해싱하여 저장한다.
- 비밀번호는 향후 리뷰 수정/삭제 시 본인 확인 용도로 사용된다.

### BR3. 리뷰 저장
- 리뷰는 Supabase의 reviews 테이블에 저장된다.
- 저장 시 created_at과 updated_at은 자동으로 현재 시각(UTC)으로 설정된다.
- place_id는 places 테이블의 유효한 레코드를 참조해야 한다 (Foreign Key 제약).

### BR4. 평균 별점 계산
- 평균 별점은 해당 장소의 모든 리뷰 별점의 산술 평균으로 계산된다.
- 소수점 첫째 자리까지 표시한다 (예: 4.5).
- 리뷰가 0개인 경우 평균 별점은 표시하지 않는다.

### BR5. 리뷰 정렬
- 리뷰 목록은 최신 작성 순(created_at DESC)으로 정렬하여 표시한다.

### BR6. 중복 제출 방지
- 리뷰 제출 버튼 클릭 시 버튼을 비활성화하고 로딩 상태를 표시하여 중복 제출을 방지한다.
- 응답 수신 후 버튼을 다시 활성화한다.

## Sequence Diagram

```plantuml
@startuml
actor User
participant FE as "Frontend"
participant BE as "Backend"
database Database

User -> FE: 장소 세부 정보 모달에서\n"리뷰 작성하기" 클릭
FE -> FE: 리뷰 작성 모달 열기
FE -> User: 리뷰 작성 폼 표시\n(업체 정보 상단 표시)

User -> FE: 작성자명, 별점, 리뷰 내용,\n비밀번호 입력

User -> FE: "리뷰 작성하기" 버튼 클릭
FE -> FE: 클라이언트 측 유효성 검사

alt 유효성 검사 실패
    FE -> User: 에러 메시지 표시\n(예: "작성자명을 입력해주세요")
else 유효성 검사 통과
    FE -> FE: 제출 버튼 비활성화\n(중복 제출 방지)
    FE -> BE: POST /api/reviews\n(place_id, author_name,\nrating, content, password)

    BE -> BE: 백엔드 유효성 검사

    alt place_id 존재하지 않음
        BE -> FE: 400 Error\n"존재하지 않는 장소입니다"
        FE -> User: 에러 메시지 표시 후\n모달 닫기
    else 유효성 검사 통과
        BE -> BE: 비밀번호 bcrypt 해싱
        BE -> Database: INSERT INTO reviews\n(place_id, author_name,\nrating, content,\npassword_hash)
        Database -> BE: 리뷰 저장 완료\n(id, created_at 반환)
        BE -> FE: 201 Created\n생성된 리뷰 데이터 반환

        FE -> FE: 리뷰 작성 모달 닫기
        FE -> FE: 장소 세부 정보 모달로 복귀
        FE -> BE: GET /api/places/:place_id/reviews
        BE -> Database: SELECT reviews\nWHERE place_id = :place_id
        BE -> Database: SELECT AVG(rating),\nCOUNT(*) FROM reviews\nWHERE place_id = :place_id
        Database -> BE: 리뷰 목록 및 통계 반환
        BE -> FE: 업데이트된 리뷰 목록,\n평균 별점, 리뷰 개수 반환

        FE -> User: 업데이트된 리뷰 목록 표시\n(새 리뷰 포함, 평균 별점 갱신)
    end
end

@enduml
```
</file>

<file path="database.md">
# 음식점 리뷰 사이트 데이터플로우 및 데이터베이스 스키마

## 1. 데이터플로우 개요

### 1.1 핵심 데이터 엔티티

```
┌─────────────┐         ┌─────────────┐
│   Places    │◄────────│   Reviews   │
│   (장소)     │ 1     N │   (리뷰)     │
└─────────────┘         └─────────────┘
```

### 1.2 시스템 데이터 흐름

```
[네이버 장소 검색 API]
         │
         ▼
   ┌──────────┐
   │  Places  │ (캐싱)
   └──────────┘
         │
         ▼
   ┌──────────┐
   │ Reviews  │
   └──────────┘
         │
         ▼
   [평균 별점/리뷰 개수 계산]
         │
         ▼
   [클라이언트 표시]
```

---

## 2. 데이터베이스 ERD

### 2.1 테이블 관계도

```
places
├── id (PK)
├── naver_place_id (Unique)
├── name
├── address
├── phone
├── latitude
├── longitude
├── created_at
└── updated_at

reviews
├── id (PK)
├── place_id (FK → places.id)
├── author_name
├── rating
├── content
├── password_hash
├── created_at
└── updated_at
```

### 2.2 엔티티 관계

- **Places (1) : Reviews (N)** - 하나의 장소는 여러 개의 리뷰를 가질 수 있음
- **외래 키**: reviews.place_id → places.id (CASCADE)

---

## 3. 데이터베이스 스키마

### 3.1 places 테이블

음식점 장소 정보를 저장하는 테이블입니다. 네이버 장소 검색 API에서 가져온 데이터를 캐싱하여 중복 API 호출을 방지합니다.

| 컬럼명 | 타입 | 제약조건 | 설명 |
|--------|------|----------|------|
| `id` | UUID | PRIMARY KEY, DEFAULT uuid_generate_v4() | 장소 고유 ID |
| `naver_place_id` | VARCHAR(255) | UNIQUE, NOT NULL | 네이버 장소 API의 고유 ID |
| `name` | VARCHAR(255) | NOT NULL | 업체명 |
| `address` | TEXT | NOT NULL | 주소 |
| `phone` | VARCHAR(50) | NULL | 전화번호 |
| `latitude` | DECIMAL(10, 8) | NOT NULL | 위도 (지도 표시용) |
| `longitude` | DECIMAL(11, 8) | NOT NULL | 경도 (지도 표시용) |
| `created_at` | TIMESTAMP WITH TIME ZONE | DEFAULT NOW() | 생성일시 |
| `updated_at` | TIMESTAMP WITH TIME ZONE | DEFAULT NOW() | 수정일시 |

**인덱스:**
- `idx_naver_place_id` ON naver_place_id (빠른 조회)
- `idx_location` ON (latitude, longitude) (지도 범위 검색)

**제약조건:**
- `naver_place_id`는 UNIQUE하므로 중복 저장 방지

### 3.2 reviews 테이블

사용자가 작성한 리뷰 데이터를 저장하는 테이블입니다.

| 컬럼명 | 타입 | 제약조건 | 설명 |
|--------|------|----------|------|
| `id` | UUID | PRIMARY KEY, DEFAULT uuid_generate_v4() | 리뷰 고유 ID |
| `place_id` | UUID | FOREIGN KEY (places.id) ON DELETE CASCADE, NOT NULL | 장소 ID (외래 키) |
| `author_name` | VARCHAR(100) | NOT NULL | 작성자명 |
| `rating` | INTEGER | NOT NULL, CHECK (rating >= 1 AND rating <= 5) | 별점 (1~5) |
| `content` | TEXT | NOT NULL, CHECK (LENGTH(content) <= 500) | 리뷰 내용 (최대 500자) |
| `password_hash` | VARCHAR(255) | NOT NULL | 비밀번호 해시 (bcrypt) |
| `created_at` | TIMESTAMP WITH TIME ZONE | DEFAULT NOW() | 생성일시 |
| `updated_at` | TIMESTAMP WITH TIME ZONE | DEFAULT NOW() | 수정일시 |

**인덱스:**
- `idx_place_id` ON place_id (특정 장소의 리뷰 조회 최적화)
- `idx_created_at` ON created_at DESC (최신 리뷰 정렬)

**제약조건:**
- `rating`은 1~5 사이의 정수만 허용
- `content`는 최대 500자 제한
- `place_id`는 places 테이블을 참조하며, 장소 삭제 시 관련 리뷰도 CASCADE 삭제

---

## 4. 주요 기능별 데이터 흐름

### 4.1 장소 검색 및 정보 확인

```
[클라이언트]
    │
    │ 1. 검색 키워드 입력
    ▼
[네이버 장소 검색 API]
    │
    │ 2. 검색 결과 반환 (name, address, naver_place_id, lat, lng)
    ▼
[클라이언트]
    │
    │ 3. "장소 세부 정보" 버튼 클릭
    ▼
[백엔드 API: GET /api/places/:naver_place_id]
    │
    │ 4. places 테이블에서 naver_place_id로 조회
    │    - 존재하면: place 데이터 반환
    │    - 없으면: places 테이블에 INSERT 후 반환
    ▼
[백엔드 API: GET /api/places/:place_id/reviews]
    │
    │ 5. reviews 테이블에서 place_id로 리뷰 목록 조회
    │ 6. 평균 별점 및 리뷰 개수 계산
    │    SELECT
    │      AVG(rating) as avg_rating,
    │      COUNT(*) as review_count
    │    FROM reviews
    │    WHERE place_id = :place_id
    ▼
[클라이언트]
    │
    │ 7. 장소 세부 정보 모달에 표시
    │    - 업체 정보 (name, address, phone)
    │    - 평균 별점 (★★★★★)
    │    - 총 리뷰 개수
    │    - 리뷰 목록 (author_name, rating, created_at, content)
```

### 4.2 지도 마커 표시

```
[클라이언트 - 지도 로드]
    │
    │ 1. 지도 초기화 (강남역 중심)
    ▼
[백엔드 API: GET /api/places/with-reviews]
    │
    │ 2. 리뷰가 존재하는 장소 목록 조회
    │    SELECT DISTINCT p.*
    │    FROM places p
    │    INNER JOIN reviews r ON p.id = r.place_id
    ▼
[클라이언트]
    │
    │ 3. 각 장소에 커스텀 마커 표시
    │    - latitude, longitude 사용
    │    - 마커 클릭 시 place_id 저장
    │
    │ 4. 마커 클릭 이벤트
    ▼
[백엔드 API: GET /api/places/:place_id/reviews]
    │
    │ 5. 해당 장소의 리뷰 데이터 조회
    ▼
[클라이언트]
    │
    │ 6. 장소 세부 정보 모달 표시
```

### 4.3 리뷰 작성

```
[클라이언트 - 장소 세부 정보 모달]
    │
    │ 1. "리뷰 작성하기" 버튼 클릭
    ▼
[클라이언트 - 리뷰 작성 모달]
    │
    │ 2. 입력 폼 작성
    │    - author_name: string
    │    - rating: 1~5
    │    - content: string (max 500)
    │    - password: string (4자리 숫자)
    │
    │ 3. "리뷰 작성하기" 버튼 클릭
    ▼
[클라이언트 - 유효성 검사]
    │
    │ 4. 프론트엔드 유효성 검사
    │    - author_name: 필수
    │    - rating: 1~5 범위
    │    - content: 필수, 500자 이하
    │    - password: 4자리 숫자
    │
    │ 5. 검사 실패 시 에러 메시지 표시 후 중단
    ▼
[백엔드 API: POST /api/reviews]
    │
    │ 6. 요청 데이터 수신
    │    {
    │      "place_id": "uuid",
    │      "author_name": "홍길동",
    │      "rating": 5,
    │      "content": "맛있어요",
    │      "password": "1234"
    │    }
    │
    │ 7. 백엔드 유효성 검사
    │    - place_id 존재 여부 확인
    │    - rating 범위 확인 (1~5)
    │    - content 길이 확인 (≤500)
    │    - password 형식 확인 (4자리 숫자)
    │
    │ 8. password 해싱 (bcrypt)
    │    const password_hash = bcrypt.hash(password)
    │
    │ 9. reviews 테이블에 INSERT
    │    INSERT INTO reviews (
    │      place_id, author_name, rating,
    │      content, password_hash
    │    ) VALUES (...)
    ▼
[백엔드 응답]
    │
    │ 10. 생성된 리뷰 데이터 반환
    │     { "id": "uuid", "created_at": "..." }
    ▼
[클라이언트]
    │
    │ 11. 리뷰 작성 모달 닫기
    │ 12. 장소 세부 정보 모달로 복귀
    │
    │ 13. GET /api/places/:place_id/reviews 재호출
    │     - 업데이트된 리뷰 목록 조회
    │     - 새로 계산된 평균 별점 표시
```

---

## 5. API 엔드포인트와 데이터 모델 매핑

### 5.1 Places 관련 API

#### GET /api/places/:naver_place_id

**목적**: 네이버 장소 ID로 장소 정보 조회 또는 생성

**요청:**
```
GET /api/places/naver_12345678
```

**처리 로직:**
```sql
-- 1. naver_place_id로 조회
SELECT * FROM places WHERE naver_place_id = 'naver_12345678';

-- 2. 없으면 INSERT (네이버 API 데이터 기반)
INSERT INTO places (
  naver_place_id, name, address, phone, latitude, longitude
) VALUES (
  'naver_12345678', '맛집', '서울시 강남구', '02-1234-5678', 37.123456, 127.123456
) RETURNING *;
```

**응답:**
```json
{
  "id": "uuid",
  "naver_place_id": "naver_12345678",
  "name": "맛집",
  "address": "서울시 강남구",
  "phone": "02-1234-5678",
  "latitude": 37.123456,
  "longitude": 127.123456,
  "created_at": "2025-10-21T10:00:00Z",
  "updated_at": "2025-10-21T10:00:00Z"
}
```

#### GET /api/places/with-reviews

**목적**: 리뷰가 존재하는 모든 장소 조회 (지도 마커 표시용)

**요청:**
```
GET /api/places/with-reviews
```

**처리 로직:**
```sql
SELECT DISTINCT p.*
FROM places p
INNER JOIN reviews r ON p.id = r.place_id;
```

**응답:**
```json
[
  {
    "id": "uuid-1",
    "naver_place_id": "naver_12345678",
    "name": "맛집",
    "latitude": 37.123456,
    "longitude": 127.123456
  },
  {
    "id": "uuid-2",
    "naver_place_id": "naver_87654321",
    "name": "맛집2",
    "latitude": 37.654321,
    "longitude": 127.654321
  }
]
```

### 5.2 Reviews 관련 API

#### GET /api/places/:place_id/reviews

**목적**: 특정 장소의 리뷰 목록 및 통계 조회

**요청:**
```
GET /api/places/uuid-1/reviews
```

**처리 로직:**
```sql
-- 리뷰 목록 조회
SELECT
  id, author_name, rating, content, created_at
FROM reviews
WHERE place_id = 'uuid-1'
ORDER BY created_at DESC;

-- 평균 별점 및 개수
SELECT
  AVG(rating) as avg_rating,
  COUNT(*) as review_count
FROM reviews
WHERE place_id = 'uuid-1';
```

**응답:**
```json
{
  "place_id": "uuid-1",
  "avg_rating": 4.5,
  "review_count": 10,
  "reviews": [
    {
      "id": "review-uuid-1",
      "author_name": "홍길동",
      "rating": 5,
      "content": "맛있어요!",
      "created_at": "2025-10-21T10:00:00Z"
    },
    {
      "id": "review-uuid-2",
      "author_name": "김철수",
      "rating": 4,
      "content": "좋아요",
      "created_at": "2025-10-20T15:30:00Z"
    }
  ]
}
```

#### POST /api/reviews

**목적**: 새로운 리뷰 작성

**요청:**
```json
POST /api/reviews
Content-Type: application/json

{
  "place_id": "uuid-1",
  "author_name": "홍길동",
  "rating": 5,
  "content": "맛있어요!",
  "password": "1234"
}
```

**처리 로직:**
```javascript
// 1. 유효성 검사
if (!place_id || !author_name || !rating || !content || !password) {
  return { error: "필수 항목이 누락되었습니다" };
}
if (rating < 1 || rating > 5) {
  return { error: "별점은 1~5 사이여야 합니다" };
}
if (content.length > 500) {
  return { error: "리뷰 내용은 500자를 초과할 수 없습니다" };
}
if (!/^\d{4}$/.test(password)) {
  return { error: "비밀번호는 4자리 숫자여야 합니다" };
}

// 2. place_id 존재 확인
const place = await supabase.from('places').select('id').eq('id', place_id).single();
if (!place) {
  return { error: "존재하지 않는 장소입니다" };
}

// 3. 비밀번호 해싱
const password_hash = await bcrypt.hash(password, 10);

// 4. 리뷰 저장
const { data, error } = await supabase.from('reviews').insert({
  place_id,
  author_name,
  rating,
  content,
  password_hash
}).select();
```

**응답 (성공):**
```json
{
  "id": "review-uuid",
  "place_id": "uuid-1",
  "author_name": "홍길동",
  "rating": 5,
  "content": "맛있어요!",
  "created_at": "2025-10-21T10:00:00Z",
  "updated_at": "2025-10-21T10:00:00Z"
}
```

**응답 (실패):**
```json
{
  "error": "별점은 1~5 사이여야 합니다"
}
```

---

## 6. 데이터 유효성 검증 규칙

### 6.1 Places 테이블 유효성 규칙

| 필드 | 규칙 | 에러 메시지 |
|------|------|-------------|
| `naver_place_id` | - 필수 입력<br>- 문자열<br>- UNIQUE | "네이버 장소 ID는 필수입니다"<br>"이미 등록된 장소입니다" |
| `name` | - 필수 입력<br>- 최대 255자 | "장소명은 필수입니다"<br>"장소명은 255자를 초과할 수 없습니다" |
| `address` | - 필수 입력 | "주소는 필수입니다" |
| `phone` | - 선택 입력<br>- 전화번호 형식 권장 | - |
| `latitude` | - 필수 입력<br>- -90 ~ 90 범위 | "위도는 필수입니다"<br>"위도는 -90~90 사이여야 합니다" |
| `longitude` | - 필수 입력<br>- -180 ~ 180 범위 | "경도는 필수입니다"<br>"경도는 -180~180 사이여야 합니다" |

### 6.2 Reviews 테이블 유효성 규칙

| 필드 | 규칙 | 에러 메시지 |
|------|------|-------------|
| `place_id` | - 필수 입력<br>- UUID 형식<br>- places 테이블에 존재 | "장소 ID는 필수입니다"<br>"올바른 UUID 형식이 아닙니다"<br>"존재하지 않는 장소입니다" |
| `author_name` | - 필수 입력<br>- 최대 100자 | "작성자명은 필수입니다"<br>"작성자명은 100자를 초과할 수 없습니다" |
| `rating` | - 필수 입력<br>- 정수<br>- 1~5 범위 | "별점은 필수입니다"<br>"별점은 1~5 사이의 정수여야 합니다" |
| `content` | - 필수 입력<br>- 최대 500자 | "리뷰 내용은 필수입니다"<br>"리뷰 내용은 500자를 초과할 수 없습니다" |
| `password` | - 필수 입력<br>- 정확히 4자리 숫자 | "비밀번호는 필수입니다"<br>"비밀번호는 4자리 숫자여야 합니다" |

### 6.3 프론트엔드 유효성 검사 체크리스트

**리뷰 작성 폼 (클라이언트 검증):**

```javascript
// 1. 작성자명 검증
if (!author_name || author_name.trim() === '') {
  return '작성자명을 입력해주세요';
}
if (author_name.length > 100) {
  return '작성자명은 100자를 초과할 수 없습니다';
}

// 2. 별점 검증
if (!rating) {
  return '별점을 선택해주세요';
}
if (rating < 1 || rating > 5) {
  return '별점은 1~5 사이여야 합니다';
}

// 3. 리뷰 내용 검증
if (!content || content.trim() === '') {
  return '리뷰 내용을 입력해주세요';
}
if (content.length > 500) {
  return `리뷰 내용은 500자를 초과할 수 없습니다 (현재: ${content.length}자)`;
}

// 4. 비밀번호 검증
if (!password) {
  return '비밀번호를 입력해주세요';
}
if (!/^\d{4}$/.test(password)) {
  return '비밀번호는 4자리 숫자여야 합니다';
}
```

---

## 7. 데이터 보안 및 고려사항

### 7.1 비밀번호 보안

- **해싱 알고리즘**: bcrypt (salt rounds: 10)
- **저장**: 평문 비밀번호는 절대 저장하지 않음
- **검증**: 리뷰 수정/삭제 시 bcrypt.compare() 사용

### 7.2 인덱스 최적화

```sql
-- 1. 장소 검색 최적화
CREATE INDEX idx_places_naver_place_id ON places(naver_place_id);

-- 2. 지도 범위 검색 최적화 (추후 확장용)
CREATE INDEX idx_places_location ON places(latitude, longitude);

-- 3. 리뷰 조회 최적화
CREATE INDEX idx_reviews_place_id ON reviews(place_id);

-- 4. 최신 리뷰 정렬 최적화
CREATE INDEX idx_reviews_created_at ON reviews(created_at DESC);
```

### 7.3 CASCADE 정책

- **places 삭제 시**: 관련된 모든 reviews도 함께 삭제 (ON DELETE CASCADE)
- **이유**: 장소가 삭제되면 해당 장소의 리뷰는 의미가 없어지므로

### 7.4 타임스탬프 자동 관리

```sql
-- updated_at 자동 업데이트 트리거
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ language 'plpgsql';

CREATE TRIGGER update_places_updated_at BEFORE UPDATE ON places
FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_reviews_updated_at BEFORE UPDATE ON reviews
FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
```

---

## 8. 데이터 마이그레이션 전략

### 8.1 초기 마이그레이션

1. **places 테이블 생성**
2. **reviews 테이블 생성**
3. **인덱스 생성**
4. **트리거 생성**

### 8.2 시드 데이터 (선택사항)

개발/테스트 환경에서 사용할 수 있는 샘플 데이터:

```sql
-- 샘플 장소 데이터
INSERT INTO places (naver_place_id, name, address, phone, latitude, longitude)
VALUES
  ('naver_test_1', '강남 맛집', '서울시 강남구 역삼동', '02-1234-5678', 37.498095, 127.027610),
  ('naver_test_2', '홍대 카페', '서울시 마포구 홍익로', '02-8765-4321', 37.557192, 126.925381);

-- 샘플 리뷰 데이터
INSERT INTO reviews (place_id, author_name, rating, content, password_hash)
SELECT
  id,
  '테스트 사용자',
  5,
  '정말 맛있어요!',
  '$2b$10$abcdefghijklmnopqrstuvwxyz' -- 실제로는 bcrypt로 해싱된 값
FROM places
WHERE naver_place_id = 'naver_test_1';
```

---

## 9. 확장 고려사항

### 9.1 추후 추가 가능한 기능

1. **리뷰 수정/삭제**: password_hash 검증 후 UPDATE/DELETE
2. **리뷰 좋아요**: reviews_likes 테이블 추가
3. **사용자 회원가입**: users 테이블 추가, reviews.user_id 외래 키
4. **이미지 업로드**: review_images 테이블 추가 (S3/Supabase Storage 연동)
5. **카테고리 분류**: place_categories 테이블 추가

### 9.2 성능 최적화

1. **캐싱**: Redis를 사용한 평균 별점/리뷰 개수 캐싱
2. **페이지네이션**: 리뷰 목록 조회 시 LIMIT/OFFSET 적용
3. **전문 검색**: PostgreSQL Full-Text Search 활용

---

## 10. 요약

### 최소 스펙 데이터베이스 스키마

- **테이블 2개**: places, reviews
- **관계**: 1:N (places → reviews)
- **필수 인덱스**: naver_place_id, place_id, created_at
- **보안**: 비밀번호 bcrypt 해싱
- **제약조건**: rating (1~5), content (500자 이하)

### 핵심 데이터 흐름

1. **검색**: 네이버 API → Places 캐싱 → 클라이언트
2. **조회**: Places + Reviews JOIN → 평균 별점 계산 → 클라이언트
3. **작성**: 클라이언트 → 유효성 검사 → Reviews 저장 → 갱신

이 스키마는 유저플로우에 명시된 모든 기능을 지원하며, 향후 확장 가능한 구조로 설계되었습니다.
</file>

<file path="naver_map_SDK.md">
# 네이버 지도 기반 음식점 리뷰 서비스 - Next.js 연동 가이드

## 📋 연동 개요

네이버 지도 기반 음식점 리뷰 서비스를 Next.js로 개발하기 위해 **SDK와 API**를 연동합니다. Webhook은 본 프로젝트에서 필요하지 않습니다.

| 구분 | 연동 수단 | 용도 | 실행 환경 |
|------|----------|------|----------|
| 지도 표시 | 네이버 지도 JavaScript SDK | 지도 렌더링, 마커 표시, 사용자 인터랙션 | 클라이언트 |
| 음식점 검색 | 네이버 검색 API | 키워드 기반 음식점 검색 | 서버 (API Routes) |
| 주소 변환 | 네이버 Geocoding API | 주소↔좌표 상호 변환 | 서버 (API Routes) |

---

## 1️⃣ 네이버 지도 JavaScript SDK

### 사용 기능
- 지도 렌더링 및 컨트롤
- 음식점 위치 마커 표시
- 마커 클릭 이벤트 처리
- 지도 확대/축소, 이동

### 설치 및 세팅

#### 1. TypeScript 타입 정의 설치
```bash
npm install --save-dev @types/navermaps
```

#### 2. Next.js Script 컴포넌트로 SDK 로드
```tsx
// app/layout.tsx (App Router) 또는 pages/_app.tsx (Pages Router)
import Script from 'next/script';

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="ko">
      <body>
        <Script
          strategy="afterInteractive"
          src={`https://oapi.map.naver.com/openapi/v3/maps.js?ncpKeyId=${process.env.NEXT_PUBLIC_NAVER_CLIENT_ID}&submodules=geocoder`}
        />
        {children}
      </body>
    </html>
  );
}
```

### 인증정보 관리

#### 1. 네이버 클라우드 플랫폼에서 발급
1. [네이버 클라우드 플랫폼](https://www.ncloud.com) 로그인
2. Console → AI·NAVER API → Application 등록
3. 서비스 선택: **Web Dynamic Map** 체크
4. 서비스 URL 등록: `http://localhost:3000` (개발), `https://yourdomain.com` (배포)

#### 2. 환경변수 설정
```env
# .env.local
NEXT_PUBLIC_NAVER_CLIENT_ID=your_client_id_here
```

### 호출 방법

```tsx
// components/NaverMap.tsx
'use client';

import { useEffect, useRef } from 'react';

interface MapProps {
  width?: string;
  height?: string;
  initialCenter?: { lat: number; lng: number };
  initialZoom?: number;
}

export default function NaverMap({
  width = '100%',
  height = '500px',
  initialCenter = { lat: 37.5656, lng: 126.9769 },
  initialZoom = 14,
}: MapProps) {
  const mapRef = useRef<HTMLDivElement>(null);
  const naverMapRef = useRef<naver.maps.Map | null>(null);

  useEffect(() => {
    if (!mapRef.current || !window.naver) return;

    const mapOptions = {
      center: new naver.maps.LatLng(initialCenter.lat, initialCenter.lng),
      zoom: initialZoom,
      zoomControl: true,
      zoomControlOptions: {
        style: naver.maps.ZoomControlStyle.SMALL,
        position: naver.maps.Position.TOP_RIGHT,
      },
    };

    // 지도 생성
    const map = new naver.maps.Map(mapRef.current, mapOptions);
    naverMapRef.current = map;

    // 마커 추가 예시
    new naver.maps.Marker({
      position: new naver.maps.LatLng(initialCenter.lat, initialCenter.lng),
      map: map,
      title: '음식점 위치',
    });

    // 클린업
    return () => {
      naverMapRef.current?.destroy();
    };
  }, [initialCenter, initialZoom]);

  return <div ref={mapRef} style={{ width, height }} />;
}
```

---

## 2️⃣ 네이버 검색 API (지역 검색)

### 사용 기능
- 키워드 기반 음식점 검색
- 검색 결과의 좌표 정보 획득
- 음식점 상세 정보 조회

### 설치 및 세팅

#### 1. 네이버 개발자 센터에서 애플리케이션 등록
1. [네이버 개발자 센터](https://developers.naver.com) 로그인
2. Application 등록
3. 사용 API 선택: **검색 → 지역** 체크
4. 웹 서비스 URL 등록

### 인증정보 관리

```env
# .env.local
NEXT_PUBLIC_NAVER_CLIENT_ID=your_client_id
NAVER_CLIENT_SECRET=your_client_secret  # 서버 전용
```

### 호출 방법

#### API Route 생성 (서버 사이드)
```typescript
// app/api/search/places/route.ts
import { NextResponse } from 'next/server';

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const query = searchParams.get('query');
  const display = searchParams.get('display') || '5';
  
  if (!query) {
    return NextResponse.json(
      { error: 'Query parameter is required' },
      { status: 400 }
    );
  }

  try {
    const url = `https://openapi.naver.com/v1/search/local.json?query=${encodeURIComponent(
      query
    )}&display=${display}&sort=random`;

    const response = await fetch(url, {
      headers: {
        'X-Naver-Client-Id': process.env.NEXT_PUBLIC_NAVER_CLIENT_ID!,
        'X-Naver-Client-Secret': process.env.NAVER_CLIENT_SECRET!,
      },
    });

    if (!response.ok) {
      throw new Error(`API responded with status ${response.status}`);
    }

    const data = await response.json();
    
    // 음식점 데이터 가공
    const restaurants = data.items.map((item: any) => ({
      title: item.title.replace(/<[^>]*>/g, ''), // HTML 태그 제거
      address: item.address,
      roadAddress: item.roadAddress,
      mapx: item.mapx,
      mapy: item.mapy,
      category: item.category,
      telephone: item.telephone,
      link: item.link,
    }));

    return NextResponse.json({ restaurants, total: data.total });
  } catch (error) {
    console.error('Search API Error:', error);
    return NextResponse.json(
      { error: 'Failed to search places' },
      { status: 500 }
    );
  }
}
```

#### 클라이언트에서 호출
```typescript
// hooks/useSearchPlaces.ts
import { useState } from 'react';

interface Restaurant {
  title: string;
  address: string;
  roadAddress: string;
  mapx: string;
  mapy: string;
  category: string;
  telephone: string;
  link: string;
}

export function useSearchPlaces() {
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const searchPlaces = async (query: string) => {
    setLoading(true);
    setError(null);

    try {
      const response = await fetch(`/api/search/places?query=${encodeURIComponent(query)}`);
      
      if (!response.ok) {
        throw new Error('검색 요청 실패');
      }

      const data = await response.json();
      return data.restaurants;
    } catch (err) {
      setError(err instanceof Error ? err.message : '검색 중 오류 발생');
      return [];
    } finally {
      setLoading(false);
    }
  };

  return { searchPlaces, loading, error };
}
```

---

## 3️⃣ 네이버 Geocoding API

### 사용 기능
- 주소 → 좌표 변환 (Geocoding)
- 좌표 → 주소 변환 (Reverse Geocoding)
- 음식점 주소 기반 정확한 위치 표시

### 설치 및 세팅

#### 1. 네이버 클라우드 플랫폼에서 서비스 추가
1. Console → AI·NAVER API → Application
2. 기존 애플리케이션 수정
3. Maps → **Geocoding**, **Reverse Geocoding** 체크

### 인증정보 관리

Geocoding API는 SDK와 동일한 Client ID를 사용하되, 헤더 키가 다릅니다:

```env
# .env.local
NEXT_PUBLIC_NAVER_CLIENT_ID=your_client_id
NAVER_CLIENT_SECRET=your_client_secret
```

### 호출 방법

#### Geocoding API Route
```typescript
// app/api/geocode/route.ts
import { NextResponse } from 'next/server';

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const address = searchParams.get('address');
  
  if (!address) {
    return NextResponse.json(
      { error: 'Address parameter is required' },
      { status: 400 }
    );
  }

  try {
    const url = `https://naveropenapi.apigw.ntruss.com/map-geocode/v2/geocode?query=${encodeURIComponent(
      address
    )}`;

    const response = await fetch(url, {
      headers: {
        'X-NCP-APIGW-API-KEY-ID': process.env.NEXT_PUBLIC_NAVER_CLIENT_ID!,
        'X-NCP-APIGW-API-KEY': process.env.NAVER_CLIENT_SECRET!,
      },
    });

    if (!response.ok) {
      throw new Error(`Geocoding API responded with status ${response.status}`);
    }

    const data = await response.json();
    
    if (data.addresses && data.addresses.length > 0) {
      const location = data.addresses[0];
      return NextResponse.json({
        lat: parseFloat(location.y),
        lng: parseFloat(location.x),
        roadAddress: location.roadAddress,
        jibunAddress: location.jibunAddress,
      });
    }

    return NextResponse.json(
      { error: 'Address not found' },
      { status: 404 }
    );
  } catch (error) {
    console.error('Geocoding API Error:', error);
    return NextResponse.json(
      { error: 'Failed to geocode address' },
      { status: 500 }
    );
  }
}
```

#### Reverse Geocoding API Route
```typescript
// app/api/reverse-geocode/route.ts
import { NextResponse } from 'next/server';

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const lat = searchParams.get('lat');
  const lng = searchParams.get('lng');
  
  if (!lat || !lng) {
    return NextResponse.json(
      { error: 'Coordinates are required' },
      { status: 400 }
    );
  }

  try {
    const coords = `${lng},${lat}`;
    const url = `https://naveropenapi.apigw.ntruss.com/map-reversegeocode/v2/gc?coords=${coords}&output=json&orders=roadaddr,addr`;

    const response = await fetch(url, {
      headers: {
        'X-NCP-APIGW-API-KEY-ID': process.env.NEXT_PUBLIC_NAVER_CLIENT_ID!,
        'X-NCP-APIGW-API-KEY': process.env.NAVER_CLIENT_SECRET!,
      },
    });

    if (!response.ok) {
      throw new Error(`Reverse geocoding failed with status ${response.status}`);
    }

    const data = await response.json();
    
    if (data.results && data.results.length > 0) {
      const result = data.results[0];
      return NextResponse.json({
        address: result.region.area1.name + ' ' + 
                 result.region.area2.name + ' ' + 
                 result.region.area3.name,
        fullAddress: result.land?.addition0?.value || '',
      });
    }

    return NextResponse.json(
      { error: 'Address not found for coordinates' },
      { status: 404 }
    );
  } catch (error) {
    console.error('Reverse Geocoding Error:', error);
    return NextResponse.json(
      { error: 'Failed to reverse geocode' },
      { status: 500 }
    );
  }
}
```

---

## 🔧 통합 구현 예시

```tsx
// app/page.tsx
'use client';

import { useState } from 'react';
import NaverMap from '@/components/NaverMap';
import SearchBar from '@/components/SearchBar';
import { useSearchPlaces } from '@/hooks/useSearchPlaces';

export default function HomePage() {
  const [markers, setMarkers] = useState<any[]>([]);
  const { searchPlaces, loading } = useSearchPlaces();

  const handleSearch = async (keyword: string) => {
    const restaurants = await searchPlaces(keyword);
    
    // 검색 결과를 지도 마커로 변환
    const newMarkers = await Promise.all(
      restaurants.map(async (restaurant: any) => {
        // 네이버 좌표를 위경도로 변환 (필요시)
        const lat = parseFloat(restaurant.mapy) / 10000000;
        const lng = parseFloat(restaurant.mapx) / 10000000;
        
        return {
          position: { lat, lng },
          title: restaurant.title,
          info: {
            address: restaurant.roadAddress || restaurant.address,
            telephone: restaurant.telephone,
            category: restaurant.category,
          },
        };
      })
    );
    
    setMarkers(newMarkers);
  };

  return (
    <div className="h-screen flex flex-col">
      <SearchBar onSearch={handleSearch} loading={loading} />
      <NaverMap markers={markers} />
    </div>
  );
}
```

---

## 📝 체크리스트

- [x] 네이버 클라우드 플랫폼 회원가입 및 결제수단 등록
- [x] Application 등록 (Web Dynamic Map, Geocoding 선택)
- [x] 네이버 개발자 센터 Application 등록 (검색 API용)
- [x] 환경변수 설정 (.env.local)
- [x] TypeScript 타입 정의 설치 (@types/navermaps)
- [x] API Routes를 통한 서버사이드 API 호출 구현
- [x] CORS 이슈 방지를 위한 서버 프록시 구현

## ⚠️ 주의사항

1. **CORS 정책**: Geocoding API는 브라우저에서 직접 호출 불가, 반드시 API Routes 사용
2. **API 호출 제한**: 검색 API는 display 최대 5개 제한
3. **환경변수**: Client Secret은 절대 클라이언트에 노출하지 말 것
4. **무료 사용량 한도**: 
   - Web Dynamic Map: 월 10,000,000건
   - Geocoding/Reverse Geocoding: 월 3,000,000건
   - 검색 API: 일 25,000건
</file>

<file path="prd.md">
# 음식점 리뷰 사이트 PRD (Product Requirements Document)

## 1. 제품 개요

### 1.1 목적
네이버 지도 기반 음식점 검색 및 사용자 리뷰 작성/조회 플랫폼

### 1.2 핵심 가치
- 지도 기반 직관적 음식점 탐색
- 간편한 리뷰 작성 및 공유
- 실시간 음식점 정보 검색

### 1.3 기술 스택
- **지도**: 네이버 지도 SDK
- **검색**: 네이버 장소 검색 API
- **데이터베이스**: Supabase
- **프론트엔드**: React (추천)

---

## 2. 포함 페이지

### 2.1 페이지 구성
```
1. 메인 페이지 (Map View)
   └─ 전체 화면 네이버 지도
   └─ 상단 검색 바

2. 모달 컴포넌트
   ├─ 장소 검색 결과 모달
   ├─ 장소 세부 정보 모달
   └─ 리뷰 작성 모달
```

### 2.2 페이지별 주요 기능

#### A. 메인 페이지 (Map View)
- 네이버 지도 표시 (초기 중심: 강남역)
- 상단 검색 바
- 리뷰 데이터 존재 업체 커스텀 마커 표시

#### B. 장소 검색 결과 모달
- 검색 결과 리스트 표시
- 스크롤 가능한 UI
- 항목 선택 시 지도 마커 연동
- "장소 세부 정보" 버튼

#### C. 장소 세부 정보 모달
- 업체 기본 정보 (이름, 주소, 전화번호)
- 평균 별점 (★★★★★, 5점 만점)
- 총 리뷰 개수
- 리뷰 목록 (작성자, 별점, 날짜, 내용)
- "리뷰 작성하기" 버튼

#### D. 리뷰 작성 모달
- 업체 정보 헤더
- 입력 폼:
  - 작성자명 (필수)
  - 별점 선택 (1~5, 필수)
  - 리뷰 내용 (최대 500자, 필수)
  - 비밀번호 (4자리 숫자, 필수)
- 유효성 검사
- Supabase 저장

---

## 3. 사용자 여정 (User Journey)

### 3.1 타겟 유저 Segment
- **일반 사용자**: 음식점을 찾고 리뷰를 참고하는 사용자
- **리뷰 작성자**: 방문 경험을 공유하려는 사용자

### 3.2 주요 사용자 플로우

#### Journey 1: 음식점 검색 및 정보 확인
```
1. [메인 페이지] 지도 로드 (강남역 중심)
2. [메인 페이지] 검색 바에 음식점명/지역 입력
3. [장소 검색 결과 모달] 검색 결과 리스트 확인
4. [장소 검색 결과 모달] 원하는 업체 선택 → 지도 마커 강조
5. [장소 검색 결과 모달] "장소 세부 정보" 버튼 클릭
6. [장소 세부 정보 모달] 업체 정보 및 리뷰 확인
7. [장소 세부 정보 모달] 모달 닫기 → [장소 검색 결과 모달] 복귀 또는 [메인 페이지] 복귀
```

#### Journey 2: 리뷰 작성
```
1. [장소 세부 정보 모달] "리뷰 작성하기" 버튼 클릭
2. [리뷰 작성 모달] 폼 입력
   - 작성자명 입력
   - 별점 선택 (1~5)
   - 리뷰 내용 작성 (최대 500자)
   - 비밀번호 입력 (4자리 숫자)
3. [리뷰 작성 모달] "리뷰 작성하기" 버튼 클릭
4. [시스템] 유효성 검사 실행
5. [시스템] Supabase에 리뷰 저장
6. [리뷰 작성 모달] 닫기 → [장소 세부 정보 모달] 복귀
7. [장소 세부 정보 모달] 업데이트된 리뷰 목록 및 평균 별점 표시
```

#### Journey 3: 지도 마커 탐색
```
1. [메인 페이지] 지도에서 커스텀 마커 확인
2. [메인 페이지] 마커 클릭
3. [장소 세부 정보 모달] 해당 업체 정보 및 리뷰 확인
```

---

## 4. IA (Information Architecture)

### 4.1 사이트 구조
```
ROOT (/)
│
├─ Map View (메인 페이지)
│  ├─ Search Bar
│  └─ Map with Markers
│
└─ Modal Layer
   ├─ Search Results Modal
   ├─ Place Detail Modal
   └─ Review Write Modal
```

### 4.2 모달 네비게이션 규칙
- **모달 외부 클릭**: 모달 닫기
- **Back Navigation**: 
  - Review Write → Place Detail
  - Place Detail → Search Results (검색 진입) OR Map View (마커 진입)
  - Search Results → Map View

---

## 5. 핵심 기능 명세

### 5.1 지도 기능
- 네이버 지도 SDK 초기화 (중심: 강남역)
- 커스텀 마커 표시 (리뷰 데이터 존재 업체)
- 마커 클릭 이벤트 → 장소 세부 정보 모달
- 검색 결과 선택 시 마커 강조

### 5.2 검색 기능
- 네이버 장소 검색 API 호출
- 검색 결과 리스트 렌더링
- 실시간 검색 가능

### 5.3 리뷰 기능
- **조회**: Supabase에서 업체별 리뷰 불러오기
- **작성**: 
  - 필수 항목 유효성 검사
  - 비밀번호 암호화 저장 권장
  - Supabase에 저장
- **통계**: 평균 별점 계산, 리뷰 개수 표시
</file>

<file path="requirements.md">
**음식점 리뷰 사이트 개발 요구사항**

1. 개요

목표: 네이버 지도 기반의 음식점 검색, 마커 표시 및 리뷰 작성 기능을 제공하는 웹 사이트 개발.
지도/검색: 지도 표시에 네이버 지도 SDK를 사용하고, 업체 정보 검색은 네이버 장소 검색 API를 사용한다.
데이터 저장: 리뷰 데이터 저장은 Supabase를 이용한다.

2. 페이지별 기능 및 플로우

A. 메인 (지도)

- 지도 표시: 네이버 지도 SDK를 사용하여 지도를 표시하며, 초기 중심점은 '강남역'으로 한다.
- 검색: 상단 장소 검색폼을 통해 업체 검색 시, 장소 검색 결과 모달창을 출력한다.
- 마커: 자체 리뷰 데이터가 존재하는 모든 업체는 커스텀 마커로 지도에 표시된다.
- 모달 닫기: 모달창 바깥 클릭 시 모달이 닫히고 메인 지도 화면이 표시된다.

B. 장소 검색 결과 (모달창)

- 출력: 네이버 장소 검색 API 결과를 스크롤링 가능한 리스트 형태로 표시한다.
- 연동: 리스트 항목 선택 시 해당 장소의 마커가 지도상에 강조되며 연동된다.
- 상세 이동: 업체 리스트 항목 하단의 장소 세부 정보 버튼을 클릭해야 장소 세부 정보 모달이 열린다.

C. 장소 세부 정보 (모달창)

- 정보 표시: 업체 이름, 주소, 전화번호 등 상세 정보가 표시된다.
- 리뷰 요약: 자체 리뷰를 기반으로 계산된 평균 별점 (총 별 다섯 개 중 노란색 표시)과 총 리뷰 개수를 표시한다.
- 리뷰 목록: 기존 작성된 리뷰 (작성자, 별점, 게시일자, 내용)가 표시된다.
- 리뷰 작성 진입: 리뷰 작성하기 버튼 클릭 시 리뷰 작성 모달창을 새로 연다.
- 모달 닫기 (복귀 로직): 모달을 닫으면 직전 상태 (장소 검색 결과 모달 혹은 메인 지도)로 돌아간다.

D. 리뷰 작성 (모달창)

- 업체 정보: 해당 업체 상세 정보가 상단에 표시된다.
- 입력 폼: 다음 항목들로 구성된다:
    - 작성자명
    - 별점 (1~5점 선택)
    - 리뷰 내용 (최대 500자 제한)
    - 비밀번호 (4자리 숫자, 필수 입력)
- 데이터 처리: 리뷰 작성하기 버튼 클릭 시, 필수 정보 유효성 검사 후 자체 데이터베이스에 리뷰를 저장한다.
- 완료 후 복귀: 작성 완료 후 리뷰 작성 모달을 닫고 직전의 장소 세부 정보 모달로 돌아가서 업데이트된 리뷰 목록과 평균 별점을 표시한다.
</file>

<file path="state-management.md">
# 음식점 리뷰 사이트 상태관리 설계

## 1. State Inventory

### 1.1 Domain State (서버 데이터)
서버에서 가져온 비즈니스 도메인 데이터로, React Query로 관리됩니다.

```typescript
// Place 관련
places: Place[]                    // 리뷰가 있는 모든 장소 (지도 마커용)
selectedPlace: Place | null        // 현재 선택된 장소 상세 정보
searchResults: NaverPlace[]        // 네이버 장소 검색 결과

// Review 관련
reviews: Review[]                  // 특정 장소의 리뷰 목록
reviewStats: ReviewStats           // 평균 별점 및 리뷰 개수

// Type Definitions
interface Place {
  id: string
  naver_place_id: string
  name: string
  address: string
  phone: string | null
  latitude: number
  longitude: number
  created_at: string
  updated_at: string
}

interface NaverPlace {
  id: string                       // 네이버 place_id
  name: string
  address: string
  phone?: string
  latitude: number
  longitude: number
}

interface Review {
  id: string
  place_id: string
  author_name: string
  rating: number                   // 1~5
  content: string                  // max 500자
  created_at: string
}

interface ReviewStats {
  avg_rating: number               // 평균 별점
  review_count: number             // 총 리뷰 개수
}
```

### 1.2 UI State (화면 제어)
전역 UI 상태로, Zustand로 관리됩니다.

```typescript
// Modal 상태
modalState: 'closed' | 'search-results' | 'place-detail' | 'review-write'

// Modal Navigation Stack (복귀 로직용)
modalHistory: ModalHistoryItem[]

// Map 상태
highlightedMarkerId: string | null  // 강조 표시할 마커 ID
mapCenter: { lat: number; lng: number }  // 지도 중심 좌표

// Loading/Error 상태
status: 'idle' | 'loading' | 'success' | 'error'
error: string | null

// Type Definitions
interface ModalHistoryItem {
  type: 'search-results' | 'place-detail'
  data?: {
    placeId?: string
    naverPlaceId?: string
    searchQuery?: string
  }
}
```

### 1.3 Form State (사용자 입력)
폼 입력 상태로, react-hook-form으로 관리됩니다.

```typescript
// 검색 폼
searchQuery: string                 // 검색어

// 리뷰 작성 폼
reviewForm: {
  author_name: string               // 작성자명 (필수)
  rating: number                    // 1~5 (필수)
  content: string                   // 최대 500자 (필수)
  password: string                  // 4자리 숫자 (필수)
}

// 폼 상태
isSubmitting: boolean
validationErrors: Record<string, string>
```

### 1.4 Derived State (계산 가능한 상태)
다른 상태로부터 계산되므로 별도 저장하지 않습니다.

```typescript
// 검색 결과의 지도 마커 좌표 배열
// → searchResults.map(r => ({ lat: r.latitude, lng: r.longitude }))

// 선택된 장소의 평균 별점 표시 (★★★★☆)
// → reviews를 기반으로 계산: Math.round(reviewStats.avg_rating)

// 리뷰 작성 폼의 유효성 검사 결과
// → react-hook-form의 formState.isValid

// 현재 모달이 열려있는지 여부
// → modalState !== 'closed'

// 직전 모달 타입 (복귀용)
// → modalHistory[modalHistory.length - 1]?.type
```

---

## 2. State Transitions

### 2.1 장소 검색 플로우

| Current State | Trigger (Action) | Next State | UI Impact |
|--------------|------------------|------------|-----------|
| `modalState: 'closed'` | 검색 버튼 클릭 (검색어 입력) | `modalState: 'search-results'`<br>`status: 'loading'` | 로딩 스피너 표시 |
| `status: 'loading'` | 네이버 API 응답 성공 | `status: 'success'`<br>`searchResults: NaverPlace[]` | 검색 결과 리스트 표시 |
| `status: 'loading'` | 네이버 API 응답 실패 | `status: 'error'`<br>`error: 'API 오류 메시지'` | 에러 메시지 표시 |
| `modalState: 'search-results'` | 리스트 항목 선택 | `highlightedMarkerId: place.id` | 지도 마커 강조 표시 |
| `modalState: 'search-results'` | "장소 세부 정보" 버튼 클릭 | `modalState: 'place-detail'`<br>`modalHistory.push()` | 장소 상세 모달 표시 |
| `modalState: 'search-results'` | 모달 외부 클릭 | `modalState: 'closed'`<br>`modalHistory: []` | 메인 지도 화면 복귀 |

### 2.2 장소 상세 정보 플로우

| Current State | Trigger (Action) | Next State | UI Impact |
|--------------|------------------|------------|-----------|
| `modalState: 'place-detail'` | 장소 ID로 진입 (마커/검색) | `status: 'loading'` | 로딩 스피너 표시 |
| `status: 'loading'` | 리뷰 조회 API 성공 | `status: 'success'`<br>`reviews: Review[]`<br>`reviewStats: ReviewStats` | 장소 정보, 리뷰 목록, 평균 별점 표시 |
| `modalState: 'place-detail'` | "리뷰 작성하기" 버튼 클릭 | `modalState: 'review-write'`<br>`modalHistory.push()` | 리뷰 작성 모달 표시 |
| `modalState: 'place-detail'` | 모달 닫기 | `modalState: 'search-results'` (검색 진입 시)<br>또는 `modalState: 'closed'` (마커 진입 시)<br>`modalHistory.pop()` | 직전 상태로 복귀 |

### 2.3 리뷰 작성 플로우

| Current State | Trigger (Action) | Next State | UI Impact |
|--------------|------------------|------------|-----------|
| `modalState: 'review-write'` | 폼 입력 | `reviewForm` 각 필드 업데이트<br>`validationErrors` 실시간 검증 | 입력 필드 에러 메시지 표시 |
| `modalState: 'review-write'` | "리뷰 작성하기" 버튼 클릭 (유효성 실패) | `validationErrors` 업데이트 | 에러 메시지 하이라이트 |
| `modalState: 'review-write'` | "리뷰 작성하기" 버튼 클릭 (유효성 성공) | `isSubmitting: true`<br>`status: 'loading'` | 버튼 비활성화, 로딩 표시 |
| `status: 'loading'` | 리뷰 저장 API 성공 | `status: 'success'`<br>`modalState: 'place-detail'`<br>`modalHistory.pop()` | 장소 상세 모달로 복귀, 리뷰 목록 자동 갱신 |
| `status: 'loading'` | 리뷰 저장 API 실패 | `status: 'error'`<br>`error: 'API 오류 메시지'`<br>`isSubmitting: false` | 에러 메시지 표시, 폼 재입력 가능 |

### 2.4 지도 마커 플로우

| Current State | Trigger (Action) | Next State | UI Impact |
|--------------|------------------|------------|-----------|
| `modalState: 'closed'` | 페이지 로드 | `status: 'loading'` | 지도 초기화 (강남역 중심) |
| `status: 'loading'` | 리뷰 있는 장소 조회 API 성공 | `status: 'success'`<br>`places: Place[]` | 지도에 커스텀 마커 표시 |
| `modalState: 'closed'` | 지도 마커 클릭 | `modalState: 'place-detail'`<br>`selectedPlace: Place` | 장소 상세 모달 표시 |
| `highlightedMarkerId: null` | 검색 결과 항목 선택 | `highlightedMarkerId: place.id`<br>`mapCenter: { lat, lng }` | 마커 강조 + 지도 중심 이동 |

---

## 3. Context Structure

### 3.1 상태 관리 계층 구조

```
┌─────────────────────────────────────────────────────┐
│                  Global State                        │
│                    (Zustand)                         │
│  - Modal 상태 (modalState, modalHistory)             │
│  - Map 상태 (highlightedMarkerId, mapCenter)         │
│  - UI 상태 (status, error)                           │
└─────────────────────────────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────┐
│               Server State                           │
│              (React Query)                           │
│  - places (지도 마커용)                               │
│  - searchResults (검색 결과)                          │
│  - selectedPlace (장소 상세)                          │
│  - reviews (리뷰 목록)                                │
│  - reviewStats (리뷰 통계)                            │
└─────────────────────────────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────┐
│                 Form State                           │
│            (react-hook-form)                         │
│  - searchQuery (검색 폼)                              │
│  - reviewForm (리뷰 작성 폼)                          │
└─────────────────────────────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────┐
│                Local Component State                 │
│                   (useState)                         │
│  - 개별 UI 인터랙션 (hover, focus 등)                 │
│  - 임시 로컬 데이터 (애니메이션 상태 등)               │
└─────────────────────────────────────────────────────┘
```

### 3.2 Mermaid 계층도

```mermaid
graph TD
    A[Global State - Zustand] --> B[Modal State]
    A --> C[Map State]
    A --> D[UI State]

    E[Server State - React Query] --> F[Places]
    E --> G[Search Results]
    E --> H[Reviews]

    I[Form State - react-hook-form] --> J[Search Form]
    I --> K[Review Form]

    L[Local State - useState] --> M[UI Interactions]

    A -.서버 상태 트리거.-> E
    E -.UI 상태 업데이트.-> A
    I -.제출 시 서버 상태 갱신.-> E
```

### 3.3 상태 관리 방법

#### Global State (Zustand)
```typescript
// src/stores/useAppStore.ts
interface AppState {
  // Modal 관리
  modalState: ModalState
  modalHistory: ModalHistoryItem[]
  openModal: (type: ModalState, data?: any) => void
  closeModal: () => void
  goBackModal: () => void

  // Map 관리
  highlightedMarkerId: string | null
  mapCenter: { lat: number; lng: number }
  setHighlightedMarker: (id: string | null) => void
  setMapCenter: (lat: number, lng: number) => void

  // UI 상태
  status: Status
  error: string | null
  setStatus: (status: Status) => void
  setError: (error: string | null) => void
}

const useAppStore = create<AppState>((set, get) => ({
  modalState: 'closed',
  modalHistory: [],
  highlightedMarkerId: null,
  mapCenter: { lat: 37.498095, lng: 127.027610 }, // 강남역
  status: 'idle',
  error: null,

  openModal: (type, data) => set((state) => ({
    modalState: type,
    modalHistory: [...state.modalHistory, { type, data }]
  })),

  closeModal: () => set({
    modalState: 'closed',
    modalHistory: []
  }),

  goBackModal: () => set((state) => {
    const newHistory = [...state.modalHistory]
    newHistory.pop() // 현재 모달 제거
    const prevModal = newHistory[newHistory.length - 1]

    return {
      modalState: prevModal?.type || 'closed',
      modalHistory: newHistory
    }
  }),

  setHighlightedMarker: (id) => set({ highlightedMarkerId: id }),
  setMapCenter: (lat, lng) => set({ mapCenter: { lat, lng } }),
  setStatus: (status) => set({ status }),
  setError: (error) => set({ error })
}))
```

#### Feature State (React Query)
```typescript
// src/features/places/hooks/usePlaces.ts
export const usePlacesWithReviews = () => {
  return useQuery({
    queryKey: ['places', 'with-reviews'],
    queryFn: async () => {
      const response = await apiClient.get<Place[]>('/places/with-reviews')
      return response.data
    },
    staleTime: 5 * 60 * 1000, // 5분
    gcTime: 10 * 60 * 1000    // 10분
  })
}

export const useSearchPlaces = (query: string) => {
  return useQuery({
    queryKey: ['places', 'search', query],
    queryFn: async () => {
      const response = await apiClient.get<NaverPlace[]>('/places/search', {
        params: { query }
      })
      return response.data
    },
    enabled: !!query,
    staleTime: 1 * 60 * 1000  // 1분
  })
}

// src/features/reviews/hooks/useReviews.ts
export const useReviews = (placeId: string) => {
  return useQuery({
    queryKey: ['reviews', placeId],
    queryFn: async () => {
      const response = await apiClient.get<{
        reviews: Review[]
        avg_rating: number
        review_count: number
      }>(`/places/${placeId}/reviews`)
      return response.data
    },
    enabled: !!placeId,
    staleTime: 30 * 1000      // 30초
  })
}

export const useCreateReview = () => {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: async (data: CreateReviewInput) => {
      const response = await apiClient.post<Review>('/reviews', data)
      return response.data
    },
    onSuccess: (_, variables) => {
      // 리뷰 목록 무효화 (자동 재조회)
      queryClient.invalidateQueries({
        queryKey: ['reviews', variables.place_id]
      })
    }
  })
}
```

#### Local State (react-hook-form)
```typescript
// src/features/reviews/components/ReviewWriteModal.tsx
const reviewFormSchema = z.object({
  author_name: z.string()
    .min(1, '작성자명을 입력해주세요')
    .max(100, '작성자명은 100자를 초과할 수 없습니다'),
  rating: z.number()
    .int()
    .min(1, '별점을 선택해주세요')
    .max(5, '별점은 1~5 사이여야 합니다'),
  content: z.string()
    .min(1, '리뷰 내용을 입력해주세요')
    .max(500, '리뷰 내용은 500자를 초과할 수 없습니다'),
  password: z.string()
    .regex(/^\d{4}$/, '비밀번호는 4자리 숫자여야 합니다')
})

const ReviewWriteModal = ({ placeId }: { placeId: string }) => {
  const { goBackModal } = useAppStore()
  const createReview = useCreateReview()

  const form = useForm<ReviewFormData>({
    resolver: zodResolver(reviewFormSchema),
    defaultValues: {
      author_name: '',
      rating: 0,
      content: '',
      password: ''
    }
  })

  const onSubmit = async (data: ReviewFormData) => {
    try {
      await createReview.mutateAsync({
        place_id: placeId,
        ...data
      })
      goBackModal() // 성공 시 장소 상세 모달로 복귀
    } catch (error) {
      form.setError('root', {
        message: '리뷰 작성에 실패했습니다'
      })
    }
  }

  return (
    <form onSubmit={form.handleSubmit(onSubmit)}>
      {/* 폼 필드 */}
    </form>
  )
}
```

---

## 4. Types

### 4.1 Global State Types

```typescript
// src/stores/types.ts
type ModalState = 'closed' | 'search-results' | 'place-detail' | 'review-write'

type Status = 'idle' | 'loading' | 'success' | 'error'

interface ModalHistoryItem {
  type: Exclude<ModalState, 'closed'>
  data?: {
    placeId?: string
    naverPlaceId?: string
    searchQuery?: string
  }
}

interface AppState {
  // Modal
  modalState: ModalState
  modalHistory: ModalHistoryItem[]
  openModal: (type: Exclude<ModalState, 'closed'>, data?: any) => void
  closeModal: () => void
  goBackModal: () => void

  // Map
  highlightedMarkerId: string | null
  mapCenter: { lat: number; lng: number }
  setHighlightedMarker: (id: string | null) => void
  setMapCenter: (lat: number, lng: number) => void

  // UI
  status: Status
  error: string | null
  setStatus: (status: Status) => void
  setError: (error: string | null) => void
}
```

### 4.2 Domain Types

```typescript
// src/features/places/types.ts
interface Place {
  id: string
  naver_place_id: string
  name: string
  address: string
  phone: string | null
  latitude: number
  longitude: number
  created_at: string
  updated_at: string
}

interface NaverPlace {
  id: string                        // 네이버 place_id
  name: string
  address: string
  phone?: string
  latitude: number
  longitude: number
}

// src/features/reviews/types.ts
interface Review {
  id: string
  place_id: string
  author_name: string
  rating: number
  content: string
  created_at: string
}

interface ReviewStats {
  avg_rating: number
  review_count: number
}

interface CreateReviewInput {
  place_id: string
  author_name: string
  rating: number
  content: string
  password: string
}

interface ReviewFormData {
  author_name: string
  rating: number
  content: string
  password: string
}
```

---

## 5. Action Payloads

### 5.1 Modal Actions

```typescript
// 모달 열기
interface OpenModalPayload {
  type: 'search-results' | 'place-detail' | 'review-write'
  data?: {
    placeId?: string
    naverPlaceId?: string
    searchQuery?: string
  }
}

// 모달 닫기 (payload 없음)
type CloseModalPayload = void

// 모달 뒤로가기 (payload 없음)
type GoBackModalPayload = void
```

### 5.2 Map Actions

```typescript
// 마커 강조
interface SetHighlightedMarkerPayload {
  id: string | null
}

// 지도 중심 이동
interface SetMapCenterPayload {
  lat: number
  lng: number
}
```

### 5.3 React Query Actions

```typescript
// 장소 검색
interface SearchPlacesPayload {
  query: string
}

// 리뷰 조회
interface FetchReviewsPayload {
  placeId: string
}

// 리뷰 생성
interface CreateReviewPayload {
  place_id: string
  author_name: string
  rating: number
  content: string
  password: string
}

// 리뷰 생성 성공
interface CreateReviewSuccessPayload {
  review: Review
}

// API 실패
interface ApiFailurePayload {
  error: string
}
```

---

## 6. Initial State

### 6.1 Global State (Zustand)

```typescript
const initialAppState: AppState = {
  modalState: 'closed',
  modalHistory: [],
  highlightedMarkerId: null,
  mapCenter: {
    lat: 37.498095,     // 강남역 위도
    lng: 127.027610     // 강남역 경도
  },
  status: 'idle',
  error: null
}
```

### 6.2 Server State (React Query)

```typescript
// React Query는 자체적으로 초기 상태를 관리하므로 별도 정의 불필요
// 각 쿼리의 초기 상태는 다음과 같음:
{
  data: undefined,
  isLoading: false,
  isError: false,
  error: null
}
```

### 6.3 Form State (react-hook-form)

```typescript
const initialReviewFormState: ReviewFormData = {
  author_name: '',
  rating: 0,
  content: '',
  password: ''
}

const initialSearchFormState = {
  query: ''
}
```

---

## 7. 상태 간 데이터 흐름

### 7.1 검색 → 장소 상세 → 리뷰 작성 플로우

```mermaid
sequenceDiagram
    participant User
    participant SearchForm
    participant Zustand
    participant ReactQuery
    participant API
    participant PlaceDetail
    participant ReviewForm

    User->>SearchForm: 검색어 입력
    SearchForm->>Zustand: openModal('search-results')
    Zustand-->>SearchForm: modalState 업데이트

    SearchForm->>ReactQuery: useSearchPlaces(query)
    ReactQuery->>API: GET /places/search?query=강남
    API-->>ReactQuery: NaverPlace[]
    ReactQuery-->>SearchForm: searchResults

    User->>SearchForm: 장소 선택
    SearchForm->>Zustand: setHighlightedMarker(id)
    Zustand-->>Map: highlightedMarkerId 업데이트

    User->>SearchForm: "장소 세부 정보" 클릭
    SearchForm->>Zustand: openModal('place-detail', { placeId })
    Zustand-->>PlaceDetail: modalState, modalHistory 업데이트

    PlaceDetail->>ReactQuery: useReviews(placeId)
    ReactQuery->>API: GET /places/:placeId/reviews
    API-->>ReactQuery: { reviews, avg_rating, review_count }
    ReactQuery-->>PlaceDetail: 리뷰 데이터

    User->>PlaceDetail: "리뷰 작성하기" 클릭
    PlaceDetail->>Zustand: openModal('review-write', { placeId })
    Zustand-->>ReviewForm: modalState, modalHistory 업데이트

    User->>ReviewForm: 리뷰 작성 후 제출
    ReviewForm->>ReactQuery: useCreateReview.mutate(data)
    ReactQuery->>API: POST /reviews
    API-->>ReactQuery: Review
    ReactQuery->>ReactQuery: invalidateQueries(['reviews', placeId])
    ReactQuery-->>ReviewForm: 성공

    ReviewForm->>Zustand: goBackModal()
    Zustand-->>PlaceDetail: modalState 업데이트 (복귀)

    PlaceDetail->>ReactQuery: useReviews(placeId) 자동 재조회
    ReactQuery->>API: GET /places/:placeId/reviews
    API-->>ReactQuery: 업데이트된 리뷰 데이터
    ReactQuery-->>PlaceDetail: 새 리뷰 포함된 목록
```

### 7.2 지도 마커 클릭 플로우

```mermaid
sequenceDiagram
    participant User
    participant Map
    participant Zustand
    participant ReactQuery
    participant API
    participant PlaceDetail

    Map->>ReactQuery: usePlacesWithReviews()
    ReactQuery->>API: GET /places/with-reviews
    API-->>ReactQuery: Place[]
    ReactQuery-->>Map: 마커 표시용 장소 목록

    User->>Map: 마커 클릭
    Map->>Zustand: openModal('place-detail', { placeId })
    Zustand-->>PlaceDetail: modalState 업데이트

    PlaceDetail->>ReactQuery: useReviews(placeId)
    ReactQuery->>API: GET /places/:placeId/reviews
    API-->>ReactQuery: 리뷰 데이터
    ReactQuery-->>PlaceDetail: 장소 상세 정보 표시
```

### 7.3 데이터 동기화 전략

#### React Query Invalidation
리뷰 작성/수정/삭제 시 관련 쿼리를 무효화하여 자동 재조회:

```typescript
// 리뷰 작성 성공 시
queryClient.invalidateQueries({
  queryKey: ['reviews', placeId]
})

// 장소 추가 시 (리뷰 작성으로 새 장소 추가된 경우)
queryClient.invalidateQueries({
  queryKey: ['places', 'with-reviews']
})
```

#### Optimistic Update (선택적 구현)
리뷰 작성 시 즉시 UI 업데이트 후 서버 동기화:

```typescript
const createReview = useMutation({
  mutationFn: postReview,
  onMutate: async (newReview) => {
    // 진행 중인 쿼리 취소
    await queryClient.cancelQueries({ queryKey: ['reviews', newReview.place_id] })

    // 이전 데이터 백업
    const previousReviews = queryClient.getQueryData(['reviews', newReview.place_id])

    // 낙관적 업데이트
    queryClient.setQueryData(['reviews', newReview.place_id], (old) => ({
      ...old,
      reviews: [...old.reviews, { ...newReview, id: 'temp-id', created_at: new Date() }],
      review_count: old.review_count + 1
    }))

    return { previousReviews }
  },
  onError: (err, newReview, context) => {
    // 에러 시 롤백
    queryClient.setQueryData(['reviews', newReview.place_id], context.previousReviews)
  },
  onSettled: (data, error, variables) => {
    // 완료 후 재조회
    queryClient.invalidateQueries({ queryKey: ['reviews', variables.place_id] })
  }
})
```

---

## 8. 성능 최적화

### 8.1 메모이제이션 전략

#### Zustand Selectors
불필요한 리렌더링 방지:

```typescript
// ❌ 나쁜 예: 전체 상태 구독
const state = useAppStore()

// ✅ 좋은 예: 필요한 부분만 선택
const modalState = useAppStore((state) => state.modalState)
const openModal = useAppStore((state) => state.openModal)
```

#### React.memo
```typescript
// 지도 마커 컴포넌트 - props가 변경될 때만 리렌더링
const PlaceMarker = React.memo(({ place, isHighlighted }: Props) => {
  return (
    <NaverMapMarker
      position={{ lat: place.latitude, lng: place.longitude }}
      icon={isHighlighted ? highlightedIcon : defaultIcon}
    />
  )
}, (prevProps, nextProps) => {
  return prevProps.place.id === nextProps.place.id &&
         prevProps.isHighlighted === nextProps.isHighlighted
})
```

#### useMemo / useCallback
```typescript
const PlaceDetailModal = ({ placeId }: Props) => {
  const { data: reviewData } = useReviews(placeId)

  // 평균 별점 표시 계산 - reviews가 변경될 때만 재계산
  const starRating = useMemo(() => {
    if (!reviewData) return 0
    return Math.round(reviewData.avg_rating)
  }, [reviewData])

  // 이벤트 핸들러 - 재생성 방지
  const handleReviewWrite = useCallback(() => {
    openModal('review-write', { placeId })
  }, [placeId, openModal])

  return (
    <div>
      <StarDisplay rating={starRating} />
      <button onClick={handleReviewWrite}>리뷰 작성하기</button>
    </div>
  )
}
```

### 8.2 React Query 캐싱 전략

#### Stale Time & GC Time
```typescript
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 60 * 1000,        // 1분: 이 시간 동안 fresh 상태 유지
      gcTime: 5 * 60 * 1000,       // 5분: 이 시간 후 캐시에서 제거
      retry: 1,                     // 실패 시 1회만 재시도
      refetchOnWindowFocus: false   // 윈도우 포커스 시 자동 재조회 비활성화
    }
  }
})

// 개별 쿼리별 설정
const usePlacesWithReviews = () => {
  return useQuery({
    queryKey: ['places', 'with-reviews'],
    queryFn: fetchPlacesWithReviews,
    staleTime: 5 * 60 * 1000,      // 5분: 지도 마커는 자주 변경되지 않음
    gcTime: 10 * 60 * 1000         // 10분
  })
}

const useReviews = (placeId: string) => {
  return useQuery({
    queryKey: ['reviews', placeId],
    queryFn: () => fetchReviews(placeId),
    staleTime: 30 * 1000,           // 30초: 리뷰는 비교적 자주 확인
    gcTime: 2 * 60 * 1000           // 2분
  })
}

const useSearchPlaces = (query: string) => {
  return useQuery({
    queryKey: ['places', 'search', query],
    queryFn: () => searchPlaces(query),
    staleTime: 1 * 60 * 1000,       // 1분: 검색 결과는 빠르게 stale
    gcTime: 5 * 60 * 1000,          // 5분
    enabled: !!query                 // 검색어가 있을 때만 실행
  })
}
```

#### Prefetching
```typescript
// 검색 결과 리스트에서 호버 시 미리 가져오기
const SearchResultItem = ({ place }: Props) => {
  const queryClient = useQueryClient()

  const handleMouseEnter = () => {
    queryClient.prefetchQuery({
      queryKey: ['reviews', place.id],
      queryFn: () => fetchReviews(place.id),
      staleTime: 30 * 1000
    })
  }

  return (
    <div onMouseEnter={handleMouseEnter}>
      {place.name}
    </div>
  )
}
```

### 8.3 리렌더링 최적화

#### 상태 분리
```typescript
// ❌ 나쁜 예: 하나의 큰 상태 객체
interface AppState {
  modal: { state: ModalState; history: ModalHistoryItem[] }
  map: { highlightedId: string | null; center: { lat: number; lng: number } }
  ui: { status: Status; error: string | null }
}

// ✅ 좋은 예: 독립적인 상태로 분리
const useModalStore = create<ModalState>(...)
const useMapStore = create<MapState>(...)
const useUIStore = create<UIState>(...)
```

#### Virtual Scrolling
리뷰 목록이 많을 경우:

```typescript
import { useVirtualizer } from '@tanstack/react-virtual'

const ReviewList = ({ reviews }: Props) => {
  const parentRef = useRef<HTMLDivElement>(null)

  const virtualizer = useVirtualizer({
    count: reviews.length,
    getScrollElement: () => parentRef.current,
    estimateSize: () => 120  // 각 리뷰 아이템의 예상 높이
  })

  return (
    <div ref={parentRef} style={{ height: '400px', overflow: 'auto' }}>
      <div style={{ height: `${virtualizer.getTotalSize()}px` }}>
        {virtualizer.getVirtualItems().map((virtualItem) => (
          <ReviewItem
            key={virtualItem.key}
            review={reviews[virtualItem.index]}
            style={{
              position: 'absolute',
              top: 0,
              left: 0,
              width: '100%',
              transform: `translateY(${virtualItem.start}px)`
            }}
          />
        ))}
      </div>
    </div>
  )
}
```

---

## 9. 에러 처리 전략

### 9.1 React Query Error Boundaries

```typescript
// src/components/ErrorBoundary.tsx
import { QueryErrorResetBoundary } from '@tanstack/react-query'
import { ErrorBoundary as ReactErrorBoundary } from 'react-error-boundary'

const ErrorFallback = ({ error, resetErrorBoundary }: Props) => {
  return (
    <div>
      <h2>오류가 발생했습니다</h2>
      <p>{error.message}</p>
      <button onClick={resetErrorBoundary}>다시 시도</button>
    </div>
  )
}

export const ErrorBoundary = ({ children }: Props) => {
  return (
    <QueryErrorResetBoundary>
      {({ reset }) => (
        <ReactErrorBoundary
          onReset={reset}
          FallbackComponent={ErrorFallback}
        >
          {children}
        </ReactErrorBoundary>
      )}
    </QueryErrorResetBoundary>
  )
}
```

### 9.2 글로벌 에러 핸들러

```typescript
// src/lib/remote/api-client.ts
import axios from 'axios'
import { useAppStore } from '@/stores/useAppStore'

export const apiClient = axios.create({
  baseURL: '/api'
})

apiClient.interceptors.response.use(
  (response) => response,
  (error) => {
    const setError = useAppStore.getState().setError
    const setStatus = useAppStore.getState().setStatus

    setStatus('error')

    if (error.response) {
      // 서버 응답 에러
      setError(error.response.data.message || '서버 오류가 발생했습니다')
    } else if (error.request) {
      // 네트워크 에러
      setError('네트워크 연결을 확인해주세요')
    } else {
      // 기타 에러
      setError('알 수 없는 오류가 발생했습니다')
    }

    return Promise.reject(error)
  }
)
```

### 9.3 폼 에러 처리

```typescript
// react-hook-form의 에러 핸들링
const ReviewWriteModal = () => {
  const form = useForm<ReviewFormData>({
    resolver: zodResolver(reviewFormSchema)
  })

  const onSubmit = async (data: ReviewFormData) => {
    try {
      await createReview.mutateAsync(data)
    } catch (error) {
      if (error instanceof ApiError) {
        // 필드별 에러 매핑
        if (error.code === 'INVALID_PLACE_ID') {
          form.setError('root', { message: '존재하지 않는 장소입니다' })
        } else if (error.code === 'DUPLICATE_REVIEW') {
          form.setError('root', { message: '이미 작성한 리뷰가 있습니다' })
        } else {
          form.setError('root', { message: error.message })
        }
      }
    }
  }

  return (
    <form onSubmit={form.handleSubmit(onSubmit)}>
      {form.formState.errors.root && (
        <Alert variant="destructive">
          {form.formState.errors.root.message}
        </Alert>
      )}
      {/* 폼 필드 */}
    </form>
  )
}
```

---

## 10. 테스트 전략

### 10.1 Zustand Store 테스트

```typescript
// src/stores/__tests__/useAppStore.test.ts
import { renderHook, act } from '@testing-library/react'
import { useAppStore } from '../useAppStore'

describe('useAppStore', () => {
  beforeEach(() => {
    const store = useAppStore.getState()
    store.closeModal()
    store.setStatus('idle')
  })

  it('should open modal and update history', () => {
    const { result } = renderHook(() => useAppStore())

    act(() => {
      result.current.openModal('search-results', { query: '강남' })
    })

    expect(result.current.modalState).toBe('search-results')
    expect(result.current.modalHistory).toHaveLength(1)
    expect(result.current.modalHistory[0].data?.searchQuery).toBe('강남')
  })

  it('should go back to previous modal', () => {
    const { result } = renderHook(() => useAppStore())

    act(() => {
      result.current.openModal('search-results')
      result.current.openModal('place-detail', { placeId: '123' })
    })

    expect(result.current.modalState).toBe('place-detail')

    act(() => {
      result.current.goBackModal()
    })

    expect(result.current.modalState).toBe('search-results')
    expect(result.current.modalHistory).toHaveLength(1)
  })
})
```

### 10.2 React Query Hook 테스트

```typescript
// src/features/reviews/hooks/__tests__/useReviews.test.ts
import { renderHook, waitFor } from '@testing-library/react'
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { useReviews } from '../useReviews'

const createWrapper = () => {
  const queryClient = new QueryClient({
    defaultOptions: {
      queries: { retry: false },
      mutations: { retry: false }
    }
  })

  return ({ children }: { children: React.ReactNode }) => (
    <QueryClientProvider client={queryClient}>
      {children}
    </QueryClientProvider>
  )
}

describe('useReviews', () => {
  it('should fetch reviews successfully', async () => {
    const { result } = renderHook(() => useReviews('place-123'), {
      wrapper: createWrapper()
    })

    await waitFor(() => expect(result.current.isSuccess).toBe(true))

    expect(result.current.data?.reviews).toBeDefined()
    expect(result.current.data?.avg_rating).toBeGreaterThanOrEqual(0)
  })
})
```

---

## 11. 요약

### 11.1 상태 관리 아키텍처

```
┌─────────────────────────────────────────────────────────┐
│                   Application State                      │
├─────────────────────────────────────────────────────────┤
│ Global (Zustand)     │ Modal, Map, UI                   │
│ Server (React Query) │ Places, Reviews                  │
│ Form (RHF)           │ Search, Review Write             │
│ Local (useState)     │ Component-specific UI            │
└─────────────────────────────────────────────────────────┘
```

### 11.2 핵심 원칙

1. **상태 분리**: 각 상태 레이어는 명확한 책임을 가짐
2. **단방향 데이터 흐름**: User → Form → Server → UI 순서
3. **자동 동기화**: React Query Invalidation으로 일관성 유지
4. **선택적 구독**: Zustand Selectors로 불필요한 리렌더링 방지
5. **타입 안정성**: 모든 상태와 액션에 TypeScript 타입 적용

### 11.3 성능 최적화 체크리스트

- [x] Zustand Selectors 사용
- [x] React.memo로 컴포넌트 메모이제이션
- [x] useMemo/useCallback로 값/함수 메모이제이션
- [x] React Query 캐싱 전략 (staleTime, gcTime)
- [x] Prefetching으로 UX 개선
- [x] Virtual Scrolling (필요 시)
- [x] 상태 분리로 리렌더링 범위 최소화

### 11.4 데이터 흐름 요약

```
[User Input]
    ↓
[Form State (RHF)]
    ↓
[API Call (React Query)]
    ↓
[Server Response]
    ↓
[Cache Update & Invalidation]
    ↓
[UI State Update (Zustand)]
    ↓
[Component Re-render]
```

이 상태관리 설계는 VMC005 프로젝트의 모든 기능을 지원하며, 확장 가능하고 유지보수가 용이한 구조로 설계되었습니다.
</file>

<file path="userflow.md">
## 음식점 리뷰 사이트 기능 단위 유저 플로우 설계

제공된 PRD 및 개발 요구사항 문서를 기반으로 핵심 기능 단위의 유저 플로우를 설계했습니다. 각 플로우는 **입력 (Input)**, **처리 (Processing)**, **출력 (Output)** 단계로 구성되며 엣지 케이스를 포함합니다.

---

### 1. 장소 검색 및 정보 확인 플로우

#### A. 일반적인 검색 및 정보 확인

| 단계 | 입력 (Input) | 처리 (Processing) | 출력 (Output) |
| :--- | :--- | :--- | :--- |
| **1. 검색 시작** | [메인 페이지] 상단 검색 바에 키워드 입력 후 엔터/검색 버튼 클릭 | 1. 네이버 장소 검색 API 호출 및 검색 결과 수신. | [장소 검색 결과 모달] 출력. 검색 결과를 스크롤 가능한 리스트로 표시. |
| **2. 결과 선택** | [장소 검색 결과 모달] 리스트 항목 선택 | 1. 선택된 장소의 좌표 확인. | 1. 지도상 해당 장소의 마커 **강조** 표시. 2. 모달 상태 유지. |
| **3. 상세 진입** | [장소 검색 결과 모달] "장소 세부 정보" 버튼 클릭 | 1. 선택된 장소의 고유 ID(Place ID) 기반으로 Supabase에서 리뷰 데이터 조회. 2. 평균 별점 및 총 리뷰 개수 계산. | [장소 세부 정보 모달] 출력. 업체 기본 정보, 리뷰 요약, 리뷰 목록 표시. |
| **4. 정보 확인** | [장소 세부 정보 모달] 정보 확인 후 닫기 요청 (Back Navigation 버튼 또는 외부 클릭) | 1. 모달 닫기 로직 실행. 2. 직전 상태 확인 (검색 결과 모달). | [장소 검색 결과 모달] 복귀. |

#### B. 엣지 케이스: 검색 결과 없음

| 단계 | 입력 (Input) | 처리 (Processing) | 출력 (Output) |
| :--- | :--- | :--- | :--- |
| **검색 결과 없음** | [메인 페이지] 상단 검색 바에 존재하지 않는 키워드 입력 후 검색 | 1. 네이버 장소 검색 API 호출 결과, 데이터가 0건으로 수신됨. | [장소 검색 결과 모달] 출력. '검색 결과가 없습니다' 등의 안내 문구 표시. |

---

### 2. 지도 마커를 통한 정보 확인 플로우

| 단계 | 입력 (Input) | 처리 (Processing) | 출력 (Output) |
| :--- | :--- | :--- | :--- |
| **1. 마커 클릭** | [메인 페이지] 지도 위의 **커스텀 마커** 클릭 | 1. 해당 마커와 연결된 장소의 고유 ID 확인. 2. Supabase에서 리뷰 데이터 조회. 3. 평균 별점 및 총 리뷰 개수 계산. | [장소 세부 정보 모달] 출력. 업체 기본 정보, 리뷰 요약, 리뷰 목록 표시. |
| **2. 모달 닫기** | [장소 세부 정보 모달] 닫기 요청 (외부 클릭 또는 Back Navigation) | 1. 모달 닫기 로직 실행. 2. 직전 상태 확인 (메인 지도). | [메인 페이지] 복귀. 지도 화면 표시. |

---

### 3. 리뷰 작성 플로우

#### A. 일반적인 리뷰 작성

| 단계 | 입력 (Input) | 처리 (Processing) | 출력 (Output) |
| :--- | :--- | :--- | :--- |
| **1. 작성 진입** | [장소 세부 정보 모달] "리뷰 작성하기" 버튼 클릭 | 1. 해당 업체의 기본 정보를 Review Write 모달에 전달. | [리뷰 작성 모달] 출력. 상단에 업체 정보 표시. |
| **2. 폼 입력** | [리뷰 작성 모달] 입력 폼에 모든 필수 항목 입력 완료: 1. 작성자명. 2. 별점 (1~5점). 3. 리뷰 내용 (최대 500자 이내). 4. 비밀번호 (4자리 숫자). | *(시스템 대기)* | *(출력 없음)* |
| **3. 저장 요청** | [리뷰 작성 모달] "리뷰 작성하기" 버튼 클릭 | 1. 입력된 모든 필수 항목에 대한 **유효성 검사** 실행. 2. (유효성 통과 시) 리뷰 데이터를 Supabase에 저장 (비밀번호 암호화 권장). | 1. [리뷰 작성 모달] 닫기. 2. [장소 세부 정보 모달] 복귀. 3. Supabase 데이터 재조회 후 **업데이트된** 리뷰 목록 및 평균 별점 표시. |

#### B. 엣지 케이스: 유효성 검사 실패

| 단계 | 입력 (Input) | 처리 (Processing) | 출력 (Output) |
| :--- | :--- | :--- | :--- |
| **필수 항목 누락** | [리뷰 작성 모달] 필수 항목 중 일부 (작성자명, 별점, 내용, 비밀번호)를 누락하거나, 내용이 500자를 초과하거나, 비밀번호가 4자리 숫자가 아닌 상태로 "리뷰 작성하기" 버튼 클릭 | 1. 입력된 데이터에 대해 유효성 검사 실행. 2. 검사 결과 실패. | [리뷰 작성 모달] **유효성 검사 실패 안내** 메시지 표시 (예: "별점을 선택해주세요" 또는 "비밀번호는 4자리 숫자여야 합니다"). 모달 상태 유지. |
</file>

</files>
